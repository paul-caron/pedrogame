<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pedro Escobar</title>
    <style>
        body {
            user-select: none;
            margin: 0;
        }

        #dialogBox {
            width: 100%;
            text-align: center;
            text-shadow: -2px 2px 0px black, 2px 2px 0px black,
                -2px -2px 0px black, 2px -2px 0px black;
            color: #B77;
            font-weight: bolder;
            font-size: 3em;
            z-index: 2;
            position: fixed;
            left: 0px;
            top: 2em;
            white-space: pre-wrap;
        }

        #buttons {
            visibility: hidden;
        }

        button,
        #music,
        #zoomIn,
        #zoomOut {
            padding: 0px 0px 0px 0px;
            box-sizing: border-box;
            position: fixed;
            z-index: 10;
            font-size: 3em;
            height: 1em;
            line-height: 1em;
            text-align: center;
            width: 1em;
            font-style: new courier, monospace;
            border-radius: 50%;
            padding: 0px 0px 0px 0px;
            margin: 0px 0px 0px 0px;
            border: 2px solid brown;
        }

        #music {
            left: 0;
            top: 0;
        }

        #zoomIn {
            left: 0;
            top: 1em;
        }

        #zoomOut {
            left: 0em;
            top: 2em;
        }

        canvas {
            background-color: beige;
            top: 0px;
            left: 0px;
            display: block;
            border: 1px solid white;
        }

        audio {
            display: none;
        }
    </style>
</head>

<body>
    <pre id="dialogBox"></pre>
    <div id="buttons">
        <button id="left" style="left: 0em; bottom: 4em;">&nbsp;</button>
        <button id="up" style="left: 1em; bottom: 5em;">&nbsp;</button>
        <button id="right" style="left: 2em; bottom: 4em;">&nbsp;</button>
        <button id="down" style="left: 1em; bottom: 3em;">&nbsp;</button>
        <button id="attack" style="right: 1em; bottom: 4em;"></button>
    </div>
    <audio id="hardgroove" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/pedrohard.mp3" type="audio/mp3"
        preload="auto" loop>
    </audio>
    <audio id="fmtechno" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/fmtechno.mp3" type="audio/mp3"
        preload="auto" loop>
    </audio>
    <audio id="ether" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/pedroEther.mp3" type="audio/mp3"
        preload="auto" loop>
    </audio>
    <audio id="dorienigm" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/dorienigm.mp3" type="audio/mp3"
        preload="auto" loop>
    </audio>
    <button id="music" onClick="audio.paused?audio.play():audio.pause();">ðŸŽµ</button>
    <button id="zoomIn" onClick="zoomFactor-=0.25;">&plus;</button>
    <button id="zoomOut" onClick="zoomFactor+=0.25;">&minus;</button>
    <canvas id="webglCanvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
    <script>
        // Globals
        let level;
        let protagonist;
        let background;
        let bullets;
        let audios = ["#fmtechno", "#hardgroove", "#dorienigm"];
        let audioIndex = 2;
        let audio = document.querySelector(audios[audioIndex]);
        let gl;
        let program;
        let textures;
        let zoomFactor = 1.0;
        // Variables for world offset and control keys
        let worldOffsetX = 0;
        let worldOffsetY = 0;
        let keys = {};
        let controlsEnabled = true;
        let collectables = {
            //'item': number,
        };

        function dialog(text, callback = () => { }) {
            const dialogBox = document.getElementById('dialogBox');
            dialogBox.innerText = text;
            setTimeout(() => {
                dialogBox.innerText = "";
                callback();
            },
                3000);
        }

        function restart(){
            keys = {};
            level = new window[level.constructor.name]();
            let weapon = protagonist.weapon;
            let ammoType = protagonist.ammoType;
            let strength = protagonist.strength;
            let speed = protagonist.speed;
            protagonist = new Protagonist();
            protagonist.weapon = weapon;
            protagonist.ammoType = ammoType;
            protagonist.strength = strength;
            protagonist.speed = speed;
            audio.pause();
            audio = document.querySelector(audios[audioIndex]);
            audio.play();
        }

        function die() {
            protagonist.dead = true;
            audio.pause();
            audio = document.querySelector("#ether");
            audio.play();
        //    let optionBox = () => {
                let answer = confirm('restart level?');
                if(answer) restart();
        //    };
        //    setTimeout(optionBox, 2000);
        }

        function initLevel() {
            controlsEnabled = true;
            bullets = [];
            worldOffsetX = 0;
            worldOffsetY = 0;
            return { colliders: [], enemies: [], drawables: [], movers: [], transitionProgress: 0.0 }
        }

        const assetsRoot = "assets/";
        //const assetsRoot = "https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/";

        const textureURLs = [
            assetsRoot + 'sierpinski.png',
            assetsRoot + 'pedro.png',
            assetsRoot + 'pedro2.png',
            assetsRoot + 'brick.png',
            assetsRoot + 'chest.png',
            assetsRoot + 'chest2.png',
            assetsRoot + 'chest3.png',
            assetsRoot + 'portal.png',
            assetsRoot + 'portal1.png',
            assetsRoot + 'portal2.png',
            assetsRoot + 'portal3.png',
            assetsRoot + 'portal4.png',
            assetsRoot + 'portal5.png',
            assetsRoot + 'syringe_up.png',
            assetsRoot + 'syringe_right.png',
            assetsRoot + 'syringe_down.png',
            assetsRoot + 'syringe_left.png',
            assetsRoot + 'chestopen.png',
            assetsRoot + 'dea.png',
            assetsRoot + 'dea2.png',
            assetsRoot + 'bloodparticle.png',
            assetsRoot + 'transparent.png',
            assetsRoot + 'npc.png',
            assetsRoot + 'npc2.png',
            assetsRoot + 'leaff.png',
            assetsRoot + 'ice.png',
            assetsRoot + 'ice2.png',
            assetsRoot + 'bubble.png',
            assetsRoot + 'doge.png',
            assetsRoot + 'doge2.png',
            assetsRoot + 'grump.png',
            assetsRoot + 'grump2.png',
            assetsRoot + 'selena.png',
            assetsRoot + 'selena2.png',
            assetsRoot + 'eye.png',
            assetsRoot + 'eye2.png',
            assetsRoot + 'eye3.png',
            assetsRoot + 'switch.png',
            assetsRoot + 'switch2.png',
            assetsRoot + 'switch3.png',
        ];

        // vertices for the background x,y,z,u,v
        const backgroundVertices = new Float32Array([
            -1, 1, 0.0, 0.0, 1.0,
            -1, -1, 0.0, 0.0, 0.0,
            1, 1, 0.0, 1.0, 1.0,
            -1, -1, 0.0, 0.0, 0.0,
            1, 1, 0.0, 1.0, 1.0,
            1, -1, 0.0, 1.0, 0.0,
        ]);

        // tile vertices x,y,z,u,v
        const sz = 0.03125;
        const tileVertices = new Float32Array([
            -sz, sz, 0.0, 0.0, 1.0,
            -sz, -sz, 0.0, 0.0, 0.0,
            sz, sz, 0.0, 1.0, 1.0,
            -sz, -sz, 0.0, 0.0, 0.0,
            sz, sz, 0.0, 1.0, 1.0,
            sz, -sz, 0.0, 1.0, 0.0,
        ]);

        const getVertices = (size, offsetU = 0, offsetV = 0, div = 1) => {
        const vertices = new Float32Array([
            -size, size, 0.0, (0.0/div+offsetU), (1.0/div+offsetV),
            -size, -size, 0.0, (0.0/div+offsetU), (0.0/div+offsetV),
            size, size, 0.0, (1.0/div+offsetU), (1.0/div+offsetV),
            -size, -size, 0.0, (0.0/div+offsetU), (0.0/div+offsetV),
            size, size, 0.0, (1.0/div+offsetU), (1.0/div+offsetV),
            size, -size, 0.0, (1.0/div+offsetU), (0.0/div+offsetV),
        ]);
        return vertices;

        };

        // boss vertices x,y,z,u,v
        const boss_sz = sz * 4;
        const bossVertices = new Float32Array([
            -boss_sz, boss_sz, 0.0, 0.0, 1.0,
            -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
            boss_sz, boss_sz, 0.0, 1.0, 1.0,
            -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
            boss_sz, boss_sz, 0.0, 1.0, 1.0,
            boss_sz, -boss_sz, 0.0, 1.0, 0.0,
        ]);

        // Drawable Tile Class
        class Drawable {
            constructor(_textures, vertices, x = 0, y = 0, z = 0) { //WebglTexturesIndices, VerticesArray (x,y,z,u,v), x, y, z)
                this.textureIndices = _textures;
                this.textures = _textures.map((i) => textures[i]);
                this.textureIndex = 0; // index to active texture
                this.vertices = vertices;
                this.positionOffset = [0, 0, 0];
                this.textureOffset = [0, 0];
                this.animations = {
                    "idle":
                    {
                        "timePerFrame": 0, // time between animation frames
                        "counter": 0,      // time counter for time left until next texture is displayed
                        "textureIndices": [0], // texture indices in order of appearance in the animation
                        "indexPointer": 0, // current index of textureIndices
                    },
                };
                this.animation = "idle"; //current animation name
                this.x = x;
                this.y = y;
                this.z = z;
                this.collisionAction = () => { };
            }
            draw(dt) { // delta time from previous render
                gl.useProgram(program);
                gl.uniform2f(program.textureOffsetLocation, ...this.textureOffset);
                gl.uniform3f(program.positionOffsetLocation,
                    this.x + this.positionOffset[0],
                    this.y + this.positionOffset[1],
                    this.z + this.positionOffset[2]);
                let animation = this.animations[this.animation];
                this.textureIndex = animation.textureIndices[animation.indexPointer];
                gl.bindTexture(gl.TEXTURE_2D, this.textures[this.textureIndex]);
                gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                animation.counter -= dt;
                if (animation.counter < 0) {
                    animation.counter = animation.timePerFrame;
                    animation.indexPointer++;
                    animation.indexPointer %= animation.textureIndices.length;
                }
            }
        };

        // Mixin
        const Collider = {
            halfWidth: 0,
            x: 0,
            y: 0,
            isColliding: function (x2, y2, halfWidth2) {// other object's values
                let x1 = this.x;
                let y1 = this.y;
                let halfWidth1 = this.halfWidth;
                const horizontalOverlap = Math.abs(x1 - x2) < (halfWidth1 + halfWidth2);
                const verticalOverlap = Math.abs(y1 - y2) < (halfWidth1 + halfWidth2);
                return horizontalOverlap && verticalOverlap;
            },
            collisionAction: function () { } // to override; callback called when collision happens
        };

        // Mixin
        const Doomed = {
            lifetime: 2000,
            expired: false,
            expire: function (dt) {
                this.lifetime -= dt;
                if (this.lifetime < 0) {
                    this.expired = true;
                    this.expiring(dt);
                }
            },
            expiring: function (dt){
                //override this callback, is called when object's lifetime expires
            },
        }

        // Mixin
        const Mover = {
            x: 0,
            y: 0,
            dx: 0,
            dy: 0,
            move: function (dt) {
                if (this.dead) return;
                this.x += this.dx;
                this.y += this.dy;
                this.updateDxy();
            },
            updateDxy: function (dt) { // to override
                //this.dx = ...;
                //this.dy = ...;
            },
        };

        class Bullet extends Drawable {
            constructor(sz, textures, vertices, x = 0, y = 0, z = 0) {
                super(textures, vertices, x, y, z);
                Object.assign(this, Mover);
                Object.assign(this, Doomed);
                Object.assign(this, Collider);
                this.halfWidth = sz;
                this.x = x;
                this.y = y;
                this.power = 1; //damage power
                this.animations.spin = {
                    "timePerFrame": 100, // time between animation frames
                    "counter": 0,      // time counter for time left until next texture is displayed
                    "textureIndices": [0, 1, 2, 3], // texture indices in order of appearance in the animation
                    "indexPointer": 0, // current index of textureIndices
                };
            }
            damage = function (enemy) {
                enemy.life -= this.power;
                if (enemy.life <= 0) enemy.dead = true;
                if (enemy.dead) enemy.lifetime = 2000;
            }
        }

        class Bubble extends Bullet {
            constructor(x, y, z, size = sz) {
                super(size, [27], getVertices(size), x, y, z);
            }
        }

        class Fixture extends Drawable {
            constructor(sz, textures, vertices, x = 0, y = 0, z = 0) {
                super(textures, vertices, x, y, z);
                Object.assign(this, Collider);
                this.halfWidth = sz;
                this.x = x;
                this.y = y;
            }
        }

        class Enemy extends Drawable {
            constructor(sz, textures, vertices, x = 0, y = 0, z = 0) {
                super(textures, vertices, x, y, z);
                Object.assign(this, Mover);
                Object.assign(this, Collider);
                Object.assign(this, Doomed);
                this.halfWidth = sz;
                this.x = x;
                this.y = y;
                this.life = 10;
                this.lifetime = Infinity;
                this.expiring = () => {
                    let shard1 = new Drawable(
                                     this.textureIndices,
                                     getVertices(this.halfWidth/2, 0,0,2));
                    Object.assign(shard1, Mover);
                    Object.assign(shard1, Doomed);
                    shard1.x = this.x - sz/2;
                    shard1.y = this.y + sz/2;
                    shard1.dx = -0.0003;
                    shard1.dy = 0.0003;
                    let shard2 = new Drawable(
                                     this.textureIndices,
                                     getVertices(this.halfWidth/2, 0.5,0,2));
                    Object.assign(shard2, Mover);
                    Object.assign(shard2, Doomed);
                    shard2.x = this.x + sz/2;
                    shard2.y = this.y + sz/2;
                    shard2.dx = 0.0003;
                    shard2.dy = 0.0003;
                    let shard3 = new Drawable(
                                     this.textureIndices,
                                     getVertices(this.halfWidth/2, 0.5,0.5,2));
                    Object.assign(shard3, Mover);
                    Object.assign(shard3, Doomed);
                    shard3.x = this.x + sz/2;
                    shard3.y = this.y - sz/2;
                    shard3.dx = 0.0003;
                    shard3.dy = -0.0003;
                    let shard4 = new Drawable(
                                     this.textureIndices,
                                     getVertices(this.halfWidth/2, 0,0.5,2));
                    Object.assign(shard4, Mover);
                    Object.assign(shard4, Doomed);
                    shard4.x = this.x - sz/2;
                    shard4.y = this.y - sz/2;
                    shard4.dx = -0.0003;
                    shard4.dy = -0.0003;
                    let particles = ((n)=>{
                        let results = [];
                        for (let i = 0; i < n ; i++){
                            results.push(new BloodParticle(this.x,this.y,0));
                        }
                        return results;
                    })(20);
                    level.drawables.push(shard1,shard2,shard3,shard4,...particles);
                    level.movers.push(shard1,shard2,shard3,shard4,...particles);
                };
            }
            dying = function () { } // override
        }

        class Particle extends Drawable {
            constructor(textures, x, y) {
                const sz = 0.004;
                const vertices = new Float32Array([
                    -sz, sz, 0.0, 0.0, 1.0,
                    -sz, -sz, 0.0, 0.0, 0.0,
                    sz, sz, 0.0, 1.0, 1.0,
                    -sz, -sz, 0.0, 0.0, 0.0,
                    sz, sz, 0.0, 1.0, 1.0,
                    sz, -sz, 0.0, 1.0, 0.0,
                ]);
                super(textures, vertices, x, y);
                Object.assign(this, Mover);
                Object.assign(this, Doomed);
                this.x = x;
                this.y = y;
                this.dx = (Math.random() - 0.5) / 400;
                this.dy = (Math.random() - 0.5) / 400;
                this.lifetime = 1000;
            }
        }

        class BloodParticle extends Particle {
            constructor(x, y) {
                super([20, 21], x, y);
                this.animations.blink = {
                    "timePerFrame": 40,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'blink';
            }
        }

        class Leaf extends Drawable {
            constructor(x, y) {
                super([24], tileVertices, x, y);
                Object.assign(this, Collider);
                Object.assign(this, Doomed);
                this.halfWidth = sz;
                this.x = x;
                this.y = y;
                this.lifetime = Infinity;
                this.collisionAction = () => {
                    if (!collectables['leaf']) collectables['leaf'] = 1;
                    else collectables['leaf'] += 1;
                    dialog(`YOU FOUND A LEAF [${collectables['leaf']}]`);
                    this.lifetime = 0;
                    this.collisionAction = () => { };
                };
            }
        };

        class Brick extends Fixture {
            constructor(x, y, z) {
                super(sz, [3], tileVertices, x, y, z);
            }
        }

        class Switch extends Fixture {
            constructor(x, y, z) {
                super(sz, [37,38,39], tileVertices, x, y, z);
                this.animations.rotate = {
                    "timePerFrame": 20,
                    "counter": 0,
                    "textureIndices": [0, 1, 2],
                    "indexPointer": 0,
                };
                this.enabled = true;
                this.collisionAction = () => {
                  if(this.enabled){
                    this.animation = this.animation==='idle'?'rotate':'idle';
                    this.enabled = false;
                    setTimeout(()=>{this.enabled = true;}, 1000);
                  }
                }
            }
        }

        class Portal extends Fixture {
            constructor(x, y, z) {
                super(sz, [7, 8, 9, 10, 11, 12], tileVertices, x, y, z);
                this.animations.idle = {
                    "timePerFrame": 20,
                    "counter": 0,
                    "textureIndices": [0, 1, 2, 3, 4, 5],
                    "indexPointer": 0,
                };
            }
        }

        class Chest extends Fixture {
            constructor(x, y, z) {
                super(sz, [6, 17], tileVertices, x, y, z);
            }
            open() {
                this.animations.idle.textureIndices = [1];
                this.collisionAction = () => { };
            }
        }

        class DEA extends Enemy {
            constructor(x, y, z) {
                super(sz, [18, 19], tileVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY THE D.E.A.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 15;
            }
        }

        class DEA_Boss extends Enemy {
            constructor(x, y, z) {
                super(boss_sz, [18, 19], bossVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY THE D.E.A.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 3000;
            }
        }

        class Grump_Boss extends Enemy {
            constructor(x, y, z) {
                super(boss_sz, [30,31], bossVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY GRUMP");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 5000;
            }
        }

        class Eye_Boss extends Enemy {
            constructor(x, y, z) {
                super(boss_sz, [34,35,36], bossVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY GRUMP");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 5000;
            }
        }

        class ICE extends Enemy {
            constructor(x, y, z) {
                super(sz, [25, 26], tileVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY I.C.E.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 50;
            }
        }

        class ICE_Boss extends Enemy {
            constructor(x, y, z) {
                super(boss_sz, [25, 26], bossVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY I.C.E.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 4500;
            }
        }

        class DOGE extends Enemy {
            constructor(x, y, z) {
                super(sz, [28, 29], tileVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 60;
            }
        }


        class DOGE_Boss extends Enemy {
            constructor(x, y, z) {
                super(boss_sz, [28, 29], bossVertices, x, y, z);
                this.collisionAction = () => {
                    die();
                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                };
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animation = 'walking';
                this.life = 4500;
            }
        }

        class Protagonist extends Drawable {
            constructor() {
                super([1, 2, 21], tileVertices, 0, 0, 0);
                this.animations.walking = {
                    "timePerFrame": 200,
                    "counter": 0,
                    "textureIndices": [0, 1],
                    "indexPointer": 0,
                };
                this.animations.attack = {
                    "timePerFrame": 0,
                    "counter": 0,
                    "textureIndices": [0],
                    "indexPointer": 0,
                };
                this.animations.blink = {
                    "timePerFrame": 20,
                    "counter": 0,
                    "textureIndices": [0, 2],
                    "indexPointer": 0,
                };
                this.weapon = null;
                this.ammoType = null;
                this.speed = 1;
                this.strength = 1;
                this.dx = 0;
                this.dy = 0;
                let bullets = [];
            }
            attack(dx, dy) {
                if (!this.weapon) return;
                if (!this.ammoType) return;
                let shoot = (offX,offY) => {
                  let bullet = new Bullet(sz, [13, 14, 15, 16], tileVertices, 0.0, 0.0, 0.0);
                  bullet.dx = dx;
                  bullet.dy = dy;
                  bullet.x = -worldOffsetX + offX;
                  bullet.y = -worldOffsetY + offY;
                  bullet.lifetime = 2000;
                  bullet.power = this.strength;
                  bullet.collisionAction = () => { };
                  bullet.animation = "spin";
                  bullets.push(bullet);
                }
                if(this.weapon==="gun") shoot(0,0);
                if(this.weapon==="double"){
                  let angle = Math.atan2(dy,dx);
                  let x1 = Math.cos(angle + Math.PI/2) * sz;
                  let y1 = Math.sin(angle + Math.PI/2) * sz;
                  shoot(x1,y1);
                  let x2 = Math.cos(angle - Math.PI/2) * sz;
                  let y2 = Math.sin(angle - Math.PI/2) * sz;
                  shoot(x2,y2);
                }
            }
            getPosition() {
                return { x: -worldOffsetX, y: -worldOffsetY };
            }
        }

        class NPC extends Fixture {
            constructor(x, y, z, text) {
                super(sz, [22, 23], tileVertices, x, y, z);
                this.text = text;
                this.collisionAction = function () {
                    dialog(this.text);
                }
            }
        };

        class Selena extends Fixture {
            constructor(x, y, z, text) {
                super(sz, [32, 33], tileVertices, x, y, z);
                this.text = text;
                this.collisionAction = function () {
                    dialog(this.text);
                }
            }
        };

        function Level1() {
            Object.assign(this, initLevel());
            protagonist = new Protagonist();
            background = new Drawable([0], backgroundVertices);

            dialog("USE ARROW KEYS TO MOVE AROUND",
                () => { dialog("SPACE BAR FOR ATTACK") });

            let brick = new Switch(0.0, 0.2, 0.0);
            let chest = new Chest(-0.2, -0.0, 0.0);
            chest.collisionAction = () => {
                protagonist.weapon = "gun";
                dialog("YOU FOUND A TRANQUILIZER GUN");
                chest.open();
            };

            let chest2 = new Chest(0.0, -0.2, 0.0);
            chest2.collisionAction = () => {
                protagonist.ammoType = "fentanyl";
                dialog("YOU FOUND FENTANYL TRANQUILIZER SHOTS");
                chest2.open();
            };
            let chest3 = new Chest(0.2, -0.0, 0.0);
            chest3.collisionAction = () => {
                dialog("YOU FOUND A LETTER FROM CHICKA MI AMOR:", () => { dialog('"HELP ME PEDRO!"<Selena Gomez>'); });
                chest3.open();
            };
            let portal = new Portal(0.0, 0.2 + sz * 2, 0.0);
            portal.collisionAction = () => {
                protagonist.animation = "blink";
                controlsEnabled = false;
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level2();
                    });
                portal.collisionAction = () => { };
            };

            let npc = new NPC(0, -0.35, 0, `"I think Grump took her to prison. Be careful of your enemies and of the booby traps."`);

            this.drawables = [chest, chest2, chest3, brick, portal, npc];
            this.colliders = [chest, chest2, chest3, brick, portal, npc];
            this.movers = [];
            this.enemies = [];
        };

        function Level2() {
            Object.assign(this, initLevel());

            let bricks = (() => {
                let result = [];
                for (let x = -15, y = 2; x < -8; x += 2, y += 2) {
                    result.push(new Brick(x * sz, -0.2 - sz * y, 0.0));
                    result.push(new Brick(x * sz, -0.2 + sz * y, 0.0));
                }
                for (let x = 15, y = 2; x > 8; x -= 2, y += 2) {
                    result.push(new Brick(x * sz, -0.2 - sz * y, 0.0));
                    result.push(new Brick(x * sz, -0.2 + sz * y, 0.0));
                }
                for (let x = -sz * 16; x <= sz * 16; x += sz * 2)
                    result.push(new Brick(x, -0.2, 0.0));
                return result;
            })();

            let bullet = new Bullet(sz, [13, 14, 15, 16], tileVertices, 0.0, 0.4, 0.0);
            bullet.dx = 0;
            bullet.dy = -0.003;
            bullet.lifetime = 2000;
            bullet.collisionAction = () => {
                die();
                dialog("YOU STEPPED ON DIRTY NEEDLE", () => {
                    dialog("NOW YOU ARE HIV POSITIVE AND GAY!");
                });
                bullet.dy = 0;
                bullet.dx = 0;
            }

            let chest = new Chest(2.0, -0.2, 0.0);
            chest.collisionAction = () => {
                dialog("YOU FOUND THE COCAINA (SPEED BUFF)");
                protagonist.speed = 2.0;
                chest.open();
            };

            let portal = new Portal(-2.0, -0.2, 0.0);
            portal.collisionAction = () => {
                protagonist.animation = "blink";
                controlsEnabled = false;
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level3();
                    });
                portal.collisionAction = () => { };
            };

            let npc = new NPC(0, -0.35, 0, `"It is a very big world we live in. Don't get lost."`);
            this.colliders = [...bricks, bullet, chest, portal, npc];
            this.drawables = [bullet, ...bricks, chest, portal, npc];
            this.movers = [bullet];
            this.enemies = [];
        }

        function Level3() {
            Object.assign(this, initLevel());

            let bricks = (() => {
                let result = [];
                for (let y = -0.4; y <= 0.4; y += sz * 2)
                    result.push(new Brick(-sz * 16, y, 0.0));
                for (let y = -0.4; y <= 0.4; y += sz * 2)
                    result.push(new Brick(sz * 16, y, 0.0));
                for (let x = -sz * 16; x < sz * 16; x += sz * 2)
                    result.push(new Brick(x, -0.4, 0.0));
                for (let x = -sz * 16; x <= sz * 16; x += sz * 2)
                    result.push(new Brick(x, 0.4, 0.0));
                return result;
            })();

            let dea = new DEA(0.2, -0.2, 0.0);
            dea.updateDxy = (dt) => {
                dea.dy = 0;
                if (dea.x >= 0.2) dea.dx = -0.0003 * dt;
                if (dea.x <= -0.2) dea.dx = 0.0003 * dt;
            };

            let portal = new Portal(0.0, 0.2, 0.0);
            portal.collisionAction = () => {
                protagonist.animation = "blink";
                controlsEnabled = false;
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level4();
                    });
                portal.collisionAction = () => { };
            };

            this.colliders = [...bricks, dea];
            this.enemies = [dea];
            this.drawables = [...bricks, dea];
            this.movers = [dea];
            dea.dying = () => {
                dialog("CONGRATS. YOUR FIRST KILL! CARTEL PRESTIGE GOES UP");
                this.colliders.push(portal);
                this.drawables.push(portal);
            };
        }

        function Level4() {
            Object.assign(this, initLevel());

            let portal = new Portal(0.0, 0.2, 0.0);
            portal.collisionAction = () => {
                protagonist.animation = "blink";
                controlsEnabled = false;
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level5();
                    });
                portal.collisionAction = () => { };
            };

            let enemies = [];
            let enemyCount = 10;
            for (let i = 1; i <= enemyCount; i++) {
                let radius = 0.2 * i + 0.5;
                let angle = Math.PI / 3 * i;
                let x = Math.cos(angle) * radius;
                let y = Math.sin(angle) * radius;
                let dea = new DEA(x, y, 0.0);
                dea.dx = 0;
                dea.dy = 0;
                dea.updateDxy = function (dt) {
                    if (!dt) return;
                    let homingTarget = protagonist.getPosition();
                    let dy = -dea.y + homingTarget.y;
                    let dx = -dea.x + homingTarget.x;
                    let angle = Math.atan2(dy, dx);
                    dea.dx = 0.0001 * dt * Math.cos(angle);
                    dea.dy = 0.0001 * dt * Math.sin(angle);
                };
                dea.dying = () => {
                    dialog(`${--enemyCount} enemies left`);
                    if (enemyCount === 0) {
                        this.drawables.push(portal);
                        this.colliders.push(portal);
                    }
                };
                enemies.push(dea);
            }

            this.colliders = [...enemies];
            this.enemies = [...enemies];
            this.drawables = [...enemies];
            this.movers = [...enemies];
        }

        function Level5() {
            Object.assign(this, initLevel());

            let bricks = (() => {
                let result = [];
                let q = 30;//18;
                for (let y = -q; y <= q; y += 12)
                    for (let x = -q; x <= q; x += 2)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let y = -q; y <= q; y += 2)
                    for (let x = -q; x <= q; x += 12)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                return result;
            })();

            let portals = (() => {
                let results = [];
                for (let y = -18; y < 18; y += 12)
                    for (let x = -18; x < 18; x += 12) {
                        let portal = new Portal((x + 2) * sz, (y + 2) * sz, 0.0);
                        results.push(portal);
                    }
                for (let y = -18; y < 18; y += 12)
                    for (let x = -18; x < 18; x += 12) {
                        let portal = new Portal((x + 10) * sz, (y + 10) * sz, 0.0);
                        results.push(portal);
                    }
                return results;
            })();

            for (let i = 0; i < 9; i++)
                portals[i].collisionAction = () => { worldOffsetX = -(portals[i + 1].x + sz * 4); worldOffsetY = -(portals[i + 1]).y - sz * 4; };
            for (let i = 9; i < 18; i++)
                portals[i].collisionAction = () => { worldOffsetX = -(portals[i - 1].x - sz * 4); worldOffsetY = -(portals[i - 1]).y + sz * 4; };

            let ports = portals.toSpliced(9, 1);
            ports[8].collisionAction = () => { worldOffsetX = -0; worldOffsetY = 0; };
            ports[ports.length - 1].collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level6();
                    });
                ports[ports.length - 1].collisionAction = () => { };
            };

            let chest = new Chest(-sz * 8, -sz * 8, 0.0);
            chest.collisionAction = () => {
                dialog("YOU FOUND THE SHROOMS (STRENGTH BUFF)");
                protagonist.strength += 1;
                chest.open();
            };

            this.colliders = [...bricks, ...ports, chest];
            this.enemies = [];
            this.drawables = [...bricks, ...ports, chest];
            this.movers = [];
        }

        function Level6() {
            Object.assign(this, initLevel());

            dialog(`"It is here that you die"`, () => {
                dialog(`"The big booty latina, Selena Gomez, is ours. Mouhahaha!"`);
            });

            let portal = new Portal(0.0, -32 * sz, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level7();
                    });
                portal.collisionAction = () => { };
            };

            let bricks = (() => {
                let result = [];
                for (let y = -18; y <= 18; y += 36)
                    for (let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let y = -18; y <= 18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                return result;
            })();

            let otherBricks = (() => {
                let result = [];
                for (let y = -36; y <= -18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let x = -18; x <= 18; x += 2)
                    result.push(new Brick(sz * x, sz * -36, 0.0));
                return result;
            })();

            let dea = new DEA_Boss(0, -0.4, 0.0);
            let animationCounter = 10000;
            dea.updateDxy = function (dt) {//dt, {x:,y:}
                let target = { x: 0, y: -0.4 };
                let speed = 0.5;
                if (animationCounter < 2000) {
                    target = protagonist.getPosition();
                    speed = 1.2;
                }
                if (!dt) return;
                let dy = -dea.y + target.y;
                let dx = -dea.x + target.x;
                let angle = Math.atan2(dy, dx);
                dea.dx = speed * 0.0003 * dt * Math.cos(angle);
                dea.dy = speed * 0.0003 * dt * Math.sin(angle);

                animationCounter -= dt;
                if (animationCounter < 0) animationCounter = 10000;
            };

            this.colliders = [dea, ...bricks];
            this.enemies = [dea];
            this.drawables = [dea, ...bricks];
            this.movers = [dea];
            dea.dying = () => {
                this.drawables.push(portal);
                this.colliders.push(portal);
                this.colliders = this.colliders.filter(c => c.y != -18 * sz);
                this.drawables = this.drawables.filter(d => d.y != -18 * sz);
                this.colliders.push(...otherBricks);
                this.drawables.push(...otherBricks);
            };
        }

        function Level7() {
            Object.assign(this, initLevel());

            let portal = new Portal(0.0, sz * 5, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level8();
                    });
                portal.collisionAction = () => { };
            };

            const n = 100;
            let npc = new NPC(0, -sz * 6, 0, `"Help this poor old farmer. Please collect ${n} of these plants"`);
            let oldCollisionAction = npc.collisionAction.bind(npc);
            npc.collisionAction = () => {
                if (collectables['leaf'] && collectables['leaf'] >= n) {
                    dialog(`"Thank you very much. Here is the exit"`);
                    this.colliders.push(portal);
                    this.drawables.push(portal);
                } else {
                    oldCollisionAction();
                }
            }
            let leaves = (() => {
                let results = [];
                for (let i = 0; i < (n); i++) {
                    let angle = i * Math.PI * 2 / (n);
                    let r = 1 + Math.sin(angle * 13);
                    let x = r * Math.cos(angle) * sz * 16;
                    let y = r * Math.sin(angle) * sz * 16 - sz * 30;
                    results.push(new Leaf(x, y));
                }
                return results;
            })();
            this.drawables = [npc, ...leaves];
            this.colliders = [npc, ...leaves];
        }

        function Level8() {
            Object.assign(this, initLevel());
            let portal = new Portal(0.0,0.2,0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level9();
                    });
                portal.collisionAction = () => { };
            };
            let ices = (()=>{
                let results = [];
                let n = 5;
                let da = Math.PI * 2 / n;
                for(let i = 0; i < n; ++i){
                    let ice = new ICE(Math.cos(da*i)*0.7, Math.sin(da*i)*0.7, 0);
                    ice.reloadTime = 2000;
                    ice.dying = () => {
                        dialog(`${--n} enemies left`);
                        if(n === 0) {
                            this.drawables.push(portal);
                            this.colliders.push(portal);
                        }
                    };
                    ice.move = (dt) => {
                        ice.reloadTime -= dt;
                        if(ice.reloadTime < 0){
                            ice.reloadTime = 2000;
                            if(!ice.dead){
                                let bubble = new Bubble(ice.x, ice.y, 0);
                                let {x,y} = protagonist.getPosition();
                                let angle = Math.atan2(y-ice.y,x-ice.x);
                                bubble.dx = Math.cos(angle) * dt * 0.0003;
                                bubble.dy = Math.sin(angle) * dt * 0.0003;
                                bubble.lifetime = 2000;
                                this.colliders.push(bubble);
                                this.drawables.push(bubble);
                                this.movers.push(bubble);
                                bubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY I.C.E.");
                                    bubble.dy = 0;
                                    bubble.dx = 0;
                               };
                            }
                        };
                    };
                    results.push(ice);
                } 
                return results;
            })();
            this.colliders = [...ices];
            this.enemies = [...ices];
            this.drawables = [...ices];
            this.movers = [...ices];
        }

        function Level9() {
            Object.assign(this, initLevel());
            let chest = new Chest(0, sz*16, 0.0);
            chest.collisionAction = () => {
                protagonist.weapon = "double";
                dialog("YOU FOUND THE DOUBLE BARRELED GUN");
                chest.open();
            };
            let portal = new Portal(0.0,-sz*12,0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level10();
                    });
                portal.collisionAction = () => { };
            };
            let movingBrick = (upper,right,lower,left,x,y,reverse)=>{
                let brick = new Brick(x,y,0);
                Object.assign(brick, Mover);
                brick.x = x;
                brick.y = y;
                let oldMove = brick.move.bind(brick);
                brick.move = (dt) => {
                  if(brick.moving){oldMove(dt);}
                };
                if(!reverse){
                  brick.updateDxy = (dt)=>{
                   const d = 0.001;
                   //if in top row
                   if(brick.y <= upper){
                       brick.y = upper;
                       // if not end of row on right
                       if(brick.x <= right){
                          brick.dx = d;
                          brick.dy = 0.000;
                       }else{
                          brick.dx = 0.000;
                          brick.dy = d;
                       }
                   }
                   //if in right column
                   else if(brick.x >= right){
                       brick.x = right;
                       // if not end of column
                       if(brick.y <= lower){
                          brick.dx = 0.000;
                          brick.dy = d;
                       }else{
                          brick.dx = -d;
                          brick.dy = 0.000;
                       }
                   }
                   //if in bottom row
                   else if(brick.y >= lower){
                       brick.y = lower;
                       // if not end of row
                       if(brick.x >= left){
                          brick.dx = -d;
                          brick.dy = 0.000;
                       }else{
                          brick.dx = 0.000;
                          brick.dy = -d;
                       }
                   }
                   //if in left column
                   else if(brick.x <= left){
                       brick.x = left;
                       // if not end of column
                       if(brick.y >= upper){
                          brick.dx = 0.000;
                          brick.dy = -d;
                       }else{
                          brick.dx = d;
                          brick.dy = 0.000;
                       }
                   }
                  };
                }else{
                  brick.updateDxy = (dt)=>{
                   //if in top row
                   const d = 0.001;
                   if(brick.y <= upper){
                       brick.y = upper;
                       // if not end of row on left
                       if(brick.x >= left){
                          brick.dx = -d;
                          brick.dy = 0.000;
                       }else{
                          brick.dx = 0.000;
                          brick.dy = d;
                       }
                   }
                   //if in left column
                   else if(brick.x <= left){
                       brick.x = left;
                       // if not end of column
                       if(brick.y <= lower){
                          brick.dx = 0.000;
                          brick.dy = d;
                       }else{
                          brick.dx = d;
                          brick.dy = 0.000;
                       }
                   }
                   //if in bottom row
                   else if(brick.y >= lower){
                       brick.y = lower;
                       // if not end of row
                       if(brick.x <= right){
                          brick.dx = d;
                          brick.dy = 0.000;
                       }else{
                          brick.dx = 0.000;
                          brick.dy = -d;
                       }
                   }
                   //if in right column
                   else if(brick.x >= right){
                       brick.x = right;
                       // if not end of column
                       if(brick.y >= upper){
                          brick.dx = 0.000;
                          brick.dy = -d;
                       }else{
                          brick.dx = -d;
                          brick.dy = 0.000;
                       }
                   }
                  };
                }
                return brick;
            };
            let square = (top,right,bottom,left,reverse)=>{
                let results = [];
                for(let y = top; y<=bottom; y+=bottom-top)
                for(let x = left; x <= right; x+= 2*sz){
                    let brick = movingBrick(top,right,bottom,left,x,y,reverse);
                    results.push(brick);
                }
                for(let x = left; x<=right; x+=right-left)
                for(let y = top+(2*sz); y < bottom; y+= 2*sz){
                    let brick = movingBrick(top,right,bottom,left,x,y,reverse);
                    results.push(brick);
                }
                return results;
            };
            let bricks = [];
            let bricks1 = square(-sz*8,sz*8,sz*8,-sz*8,false);
            bricks1.pop();
            bricks1.pop();
            let switch1 = new Switch(-sz*3,sz*3,0);
            let oldCollisionAction1 = switch1.collisionAction.bind(switch1);
            switch1.collisionAction = ()=>{
                oldCollisionAction1();
                if(switch1.animation === 'rotate'){
                    bricks1.forEach(b=>{b.moving=true;});
                }else{
                    bricks1.forEach(b=>{b.moving=false;});
                }
            };
            let bricks2 = square(-sz*10,sz*10,sz*10,-sz*10,true);
            bricks2.shift();
            bricks2.shift();
            let switch2 = new Switch(0,sz*3,0);
            let oldCollisionAction2 = switch2.collisionAction.bind(switch2);
            switch2.collisionAction = ()=>{
                oldCollisionAction2();
                if(switch2.animation === 'rotate'){
                    bricks2.forEach(b=>{b.moving=true;});
                }else{
                    bricks2.forEach(b=>{b.moving=false;});
                }
            };
            let bricks3 = square(-sz*12,sz*12,sz*12,-sz*12,false);
            bricks3.pop();
            bricks3.pop();
            let switch3 = new Switch(sz*3,sz*3,0);
            let oldCollisionAction3 = switch3.collisionAction.bind(switch3);
            switch3.collisionAction = ()=>{
                oldCollisionAction3();
                if(switch3.animation === 'rotate'){
                    bricks3.forEach(b=>{b.moving=true;});
                }else{
                    bricks3.forEach(b=>{b.moving=false;});
                }
            };
            bricks.push(...bricks1,...bricks2,...bricks3);
            this.drawables = [chest,portal,...bricks,switch1,switch2,switch3];
            this.colliders = [chest,portal,...bricks,switch1,switch2,switch3];
            this.movers = [...bricks];
        }

        function Level10() {
            Object.assign(this, initLevel());

            dialog(`"D.O.G.E. told me all about you."`, () => {
                dialog(`"You are a fool. Prepare to die!"`);
            });

            let portal = new Portal(0.0, -32 * sz, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level11();
                    });
                portal.collisionAction = () => { };
            };

            let bricks = (() => {
                let result = [];
                for (let y = -18; y <= 18; y += 36)
                    for (let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let y = -18; y <= 18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                return result;
            })();

            let otherBricks = (() => {
                let result = [];
                for (let y = -36; y <= -18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let x = -18; x <= 18; x += 2)
                    result.push(new Brick(sz * x, sz * -36, 0.0));
                return result;
            })();

            let ice = new ICE_Boss(0, -0.4, 0.0);
            let animationCounter = 10000;
            ice.reloadTime = 2000;
            let oldMove = ice.move.bind(ice);
                    ice.move = (dt) => {
                        oldMove(dt);
                        ice.reloadTime -= dt;
                        if(ice.reloadTime < 0){
                            ice.reloadTime = 2000;
                            if(!ice.dead){
                                let bubble = new Bubble(ice.x, ice.y, 0);
                                let {x,y} = protagonist.getPosition();
                                let angle = Math.atan2(y-ice.y,x-ice.x);
                                bubble.dx = Math.cos(angle) * dt * 0.0003;
                                bubble.dy = Math.sin(angle) * dt * 0.0003;
                                bubble.lifetime = 2000;
                                this.colliders.push(bubble);
                                this.drawables.push(bubble);
                                this.movers.push(bubble);
                                bubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY I.C.E.");
                                    bubble.dy = 0;
                                    bubble.dx = 0;
                               };
                            }
                        };
                    };
            ice.updateDxy = function (dt) {
                let target = { x: 0, y: -0.4 };
                let speed = 0.5;
                if (animationCounter < 2000) {
                    target = protagonist.getPosition();
                    speed = 1.2;
                }
                if (!dt) return;
                let dy = -ice.y + target.y;
                let dx = -ice.x + target.x;
                let angle = Math.atan2(dy, dx);
                ice.dx = speed * 0.0003 * dt * Math.cos(angle);
                ice.dy = speed * 0.0003 * dt * Math.sin(angle);

                animationCounter -= dt;
                if (animationCounter < 0) animationCounter = 10000;
            };

            this.colliders = [ice, ...bricks];
            this.enemies = [ice];
            this.drawables = [ice, ...bricks];
            this.movers = [ice];
            ice.dying = () => {
                this.drawables.push(portal);
                this.colliders.push(portal);
                this.colliders = this.colliders.filter(c => c.y != -18 * sz);
                this.drawables = this.drawables.filter(d => d.y != -18 * sz);
                this.colliders.push(...otherBricks);
                this.drawables.push(...otherBricks);
            };
        }

        function Level11(){
            Object.assign(this, initLevel());
            let portal = new Portal(0.0, 0.2, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level12();
                    });
                portal.collisionAction = () => { };
            };
            let n = 2;
            let enemies = [];
            for(let i=0;i<n;++i){
            let angle = (i + 0.5) * Math.PI / n;
            let x = Math.cos(angle) * sz * (10);
            let y = Math.sin(angle) * sz * (10);
            let doge = new DOGE(x, y, 0);
            doge.dying = () => {
                dialog(`${--n} enemies left`);
                if(n === 0){
                  this.drawables.push(portal);
                  this.colliders.push(portal);
                }
            };
            doge.reloadTime = 2000;
            doge.move = (dt) => {
                        doge.reloadTime -= dt;
                        if(doge.reloadTime < 0){
                            doge.reloadTime = 2000;
                            if(!doge.dead){
                                let bubble = new Bubble(doge.x, doge.y, 0);
                                bubble.initialLifetime = 2000;
                                let {x,y} = protagonist.getPosition();
                                let angle = Math.atan2(y-doge.y,x-doge.x);
                                bubble.dx = Math.cos(angle) * dt * 0.0003;
                                bubble.dy = Math.sin(angle) * dt * 0.0003;
                                bubble.lifetime = bubble.initialLifetime;
                                this.colliders.push(bubble);
                                this.drawables.push(bubble);
                                this.movers.push(bubble);
                                bubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    bubble.dy = 0;
                                    bubble.dx = 0;
                                };
                                let mult=(dt,parent)=>{
                                  let newBubble = new Bubble(parent.x, parent.y, 0, parent.halfWidth/2);
                                  newBubble.initialLifetime = parent.initialLifetime/2;
                                  newBubble.lifetime = parent.initialLifetime/2;
                                  let angle = Math.atan2(parent.dy,parent.dx);
                                  let newAngle = angle + Math.PI/2;
                                  newBubble.dx = Math.cos(newAngle) * dt * 0.0003;
                                  newBubble.dy = Math.sin(newAngle) * dt * 0.0003;

                                  let newBubble2 = new Bubble(parent.x, parent.y, 0, parent.halfWidth/2);
                                  newBubble2.initialLifetime = parent.initialLifetime/2;
                                  newBubble2.lifetime = parent.initialLifetime/2;
                                  let newAngle2 = angle - Math.PI/2;
                                  newBubble2.dx = Math.cos(newAngle2) * dt * 0.0003;
                                  newBubble2.dy = Math.sin(newAngle2) * dt * 0.0003;

                                  newBubble.expiring=(dt)=>{
                                    if(newBubble.initialLifetime<500) return;
                                    mult(dt,newBubble);
                                  }
                                  newBubble2.expiring=(dt)=>{
                                    if(newBubble2.initialLifetime<500) return;
                                    mult(dt,newBubble2);
                                  }

                                newBubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    newBubble.dy = 0;
                                    newBubble.dx = 0;
                                };
                                newBubble2.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    newBubble2.dy = 0;
                                    newBubble2.dx = 0;
                                };

                                  this.colliders.push(newBubble,newBubble2);
                                  this.drawables.push(newBubble,newBubble2);
                                  this.movers.push(newBubble,newBubble2);
                                };
                                bubble.expiring=(dt)=>{
                                  if(bubble.initialLifetime<500) return;
                                  mult(dt,bubble);
                                }
                            }
                        };

            };
            enemies.push(doge);
            }


            let bricks = (() => {
                let result = [];
                for (let y = -0.4; y <= 0.4; y += sz * 2)
                    result.push(new Brick(-sz * 16, y, 0.0));
                for (let y = -0.4; y <= 0.4; y += sz * 2)
                    result.push(new Brick(sz * 16, y, 0.0));
                for (let x = -sz * 16; x < sz * 16; x += sz * 2)
                    result.push(new Brick(x, -0.4, 0.0));
                for (let x = -sz * 16; x <= sz * 16; x += sz * 2)
                    result.push(new Brick(x, 0.4, 0.0));
                return result;
            })();

            this.drawables=[...enemies, ...bricks];
            this.colliders=[...enemies, ...bricks];
            this.movers=[...enemies];
            this.enemies=[...enemies];
        }

        function Level12() {
            Object.assign(this, initLevel());

            dialog(`"Grump put me in charge."`, () => {
                dialog(`"I am in charge of killing you!"`);
            });

            let portal = new Portal(0.0, -32 * sz, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new Level13();
                    });
                portal.collisionAction = () => { };
            };

            let bricks = (() => {
                let result = [];
                for (let y = -18; y <= 18; y += 36)
                    for (let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let y = -18; y <= 18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                return result;
            })();

            let otherBricks = (() => {
                let result = [];
                for (let y = -36; y <= -18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let x = -18; x <= 18; x += 2)
                    result.push(new Brick(sz * x, sz * -36, 0.0));
                return result;
            })();

            let doge = new DOGE_Boss(0, -0.4, 0.0);
            let animationCounter = 10000;
            doge.reloadTime = 2000;
            let oldMove = doge.move.bind(doge);
                    doge.move = (dt) => {
                        oldMove(dt);
                        doge.reloadTime -= dt;
                        if(doge.reloadTime < 0){
                            doge.reloadTime = 2000;
                            if(!doge.dead){
                                let bubble = new Bubble(doge.x, doge.y, 0);
                                bubble.initialLifetime = 2000;
                                let {x,y} = protagonist.getPosition();
                                let angle = Math.atan2(y-doge.y,x-doge.x);
                                bubble.dx = Math.cos(angle) * dt * 0.0003;
                                bubble.dy = Math.sin(angle) * dt * 0.0003;
                                bubble.lifetime = bubble.initialLifetime;
                                this.colliders.push(bubble);
                                this.drawables.push(bubble);
                                this.movers.push(bubble);
                                bubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    bubble.dy = 0;
                                    bubble.dx = 0;
                                };
                                let mult=(dt,parent)=>{
                                  let newBubble = new Bubble(parent.x, parent.y, 0, parent.halfWidth/2);
                                  newBubble.initialLifetime = parent.initialLifetime/2;
                                  newBubble.lifetime = parent.initialLifetime/2;
                                  let angle = Math.atan2(parent.dy,parent.dx);
                                  let newAngle = angle + Math.PI/2;
                                  newBubble.dx = Math.cos(newAngle) * dt * 0.0003;
                                  newBubble.dy = Math.sin(newAngle) * dt * 0.0003;

                                  let newBubble2 = new Bubble(parent.x, parent.y, 0, parent.halfWidth/2);
                                  newBubble2.initialLifetime = parent.initialLifetime/2;
                                  newBubble2.lifetime = parent.initialLifetime/2;
                                  let newAngle2 = angle - Math.PI/2;
                                  newBubble2.dx = Math.cos(newAngle2) * dt * 0.0003;
                                  newBubble2.dy = Math.sin(newAngle2) * dt * 0.0003;

                                  newBubble.expiring=(dt)=>{
                                    if(newBubble.initialLifetime<500) return;
                                    mult(dt,newBubble);
                                  }
                                  newBubble2.expiring=(dt)=>{
                                    if(newBubble2.initialLifetime<500) return;
                                    mult(dt,newBubble2);
                                  }

                                newBubble.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    newBubble.dy = 0;
                                    newBubble.dx = 0;
                                };
                                newBubble2.collisionAction = () => {
                                    die();
                                    dialog("YOU WERE CAUGHT BY D.O.G.E.");
                                    newBubble2.dy = 0;
                                    newBubble2.dx = 0;
                                };

                                  this.colliders.push(newBubble,newBubble2);
                                  this.drawables.push(newBubble,newBubble2);
                                  this.movers.push(newBubble,newBubble2);
                                };
                                bubble.expiring=(dt)=>{
                                  if(bubble.initialLifetime<500) return;
                                  mult(dt,bubble);
                                }

                            }
                        };
                    };
            doge.updateDxy = function (dt) {
                let target = { x: 0, y: -0.4 };
                let speed = 0.5;
                if (animationCounter < 2000) {
                    target = protagonist.getPosition();
                    speed = 1.2;
                }
                if (!dt) return;
                let dy = -doge.y + target.y;
                let dx = -doge.x + target.x;
                let angle = Math.atan2(dy, dx);
                doge.dx = speed * 0.0003 * dt * Math.cos(angle);
                doge.dy = speed * 0.0003 * dt * Math.sin(angle);

                animationCounter -= dt;
                if (animationCounter < 0) animationCounter = 10000;
            };

            this.colliders = [doge, ...bricks];
            this.enemies = [doge];
            this.drawables = [doge, ...bricks];
            this.movers = [doge];
            doge.dying = () => {
                this.drawables.push(portal);
                this.colliders.push(portal);
                this.colliders = this.colliders.filter(c => c.y != -18 * sz);
                this.drawables = this.drawables.filter(d => d.y != -18 * sz);
                this.colliders.push(...otherBricks);
                this.drawables.push(...otherBricks);
            };
        }

        function Level13() {
            Object.assign(this, initLevel());

            let portal = new Portal(0.0, -32 * sz, 0.0);
            portal.collisionAction = () => {
                controlsEnabled = false;
                protagonist.animation = "blink";
                dialog("YOU FOUND THE EXIT",
                    () => {
                        protagonist.animation = "idle";
                        level = new LevelEnding();
                    });
                portal.collisionAction = () => { };
            };
 
            let bricks = (() => {
                let result = [];
                for (let y = -18; y <= 18; y += 36)
                    for (let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let y = -18; y <= 18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                return result;
            })();

            let otherBricks = (() => {
                let result = [];
                for (let y = -36; y <= -18; y += 2)
                    for (let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz * x, sz * y, 0.0));
                for (let x = -18; x <= 18; x += 2)
                    result.push(new Brick(sz * x, sz * -36, 0.0));
                return result;
            })();

            let eye = new Eye_Boss(0,-0.4,0);
            eye.animationTime = 10000;
            eye.patrolY = 0.4;
            eye.resetReloadTime = () => {eye.reloadTime = 200;};
            eye.resetReloadTime();
            eye.updateDxy = (dt) => {
                if(!dt) return ;
                eye.animationTime -= dt;

                //loop animation cycle
                if(eye.animationTime < 0){
                  eye.animationTime = 10000;
                  eye.patrolY *= -1;
                }
                
                //seek
                if(eye.animationTime <= 5000){
                  let {x,y} = protagonist.getPosition();
                  let dx = x - eye.x;
                  let dy = y - eye.y;
                  let angle = Math.atan2(dy,dx);
                  let dist = Math.hypot(dy,dx);
                  let force = 0.000005 * dt;
                  eye.dx +=  force * Math.cos(angle);
                  eye.dy +=  force * Math.sin(angle);
                }

                //patrol
                if(eye.animationTime > 5000){
                  let x = 0;
                  let y = eye.patrolY;
                  let dx = x - eye.x;
                  let dy = y - eye.y;
                  let angle = Math.atan2(dy,dx);
                  let d = 0.0003 * dt;
                  eye.dx =  d * Math.cos(angle);
                  eye.dy =  d * Math.sin(angle);
                  //shoot
                  if(eye.animationTime < 6000){
                    eye.reloadTime -= dt;
                    if(eye.reloadTime < 0) {eye.resetReloadTime();
                    let n = 6;
                    for(let i = 0; i < n; ++i){
                      let bubble = new Bubble(eye.x, eye.y, 0);
                      bubble.lifetime = 6000;
                      let angle = 2 * Math.PI / n * i;
                      bubble.updateDxy = (dt) => {
                          bubble.dx = Math.cos(angle + Math.PI/360) * 0.0003 * dt;
                          bubble.dy = Math.sin(angle + Math.PI/360) * 0.0003 * dt;
                          angle += Math.PI/360;
                      };
                      level.drawables.push(bubble);
                      level.colliders.push(bubble);
                      level.movers.push(bubble);
                    }
                  }
                  }
                }                
            };

            let grump = new Grump_Boss(0,-0.4,0);
            //grump.life = 10;
            grump.reloadTime = 2000;
            let oldMove = grump.move.bind(grump);
            grump.move = (dt) => {
                oldMove(dt);
                grump.reloadTime -= dt;
                if(grump.reloadTime < 0){
                    grump.reloadTime = 2000;
                    if(!grump.dead){
                        let bubble = new Bubble(grump.x, grump.y, 0);
                        bubble.explode = () => {
                            let max = sz*6;
                            bubble.halfWidth += sz/150 *dt;
                            bubble.halfWidth = (bubble.halfWidth<max)?bubble.halfWidth: max;
                            bubble.vertices = getVertices(bubble.halfWidth);
                            if(bubble.halfWidth === max) bubble.lifetime = 0;
                        };
                        bubble.lifetime = 2000;
                        let target = protagonist.getPosition();
                        bubble.updateDxy = (dt) => {
                            let dx = target.x - bubble.x;
                            let dy = target.y - bubble.y;
                            if(Math.abs(dx+dy)<sz){
                                bubble.explode();
                            }
                            let angle = Math.atan2(dy, dx);
                            bubble.dx = Math.cos(angle) * dt * 0.0003;
                            bubble.dy = Math.sin(angle) * dt * 0.0003;
                        };
                        bubble.collisionAction = () => {
                            dialog("YOU WERE CAUGHT BY GRUMP. NO HAPPY ENDING");
                            die();
                            bubble.dy = 0;
                            bubble.dx = 0;
                        };
                        this.drawables.push(bubble);
                        this.movers.push(bubble);
                        this.colliders.push(bubble);
                    }
                }

            }; 

            let animationCounter = 10000;
            grump.updateDxy = function (dt) {
                let target = { x: 0, y: -0.4 };
                let speed = 0.5;
                if (animationCounter < 2000) {
                    target = protagonist.getPosition();
                    speed = 1.2;
                }
                if (!dt) return;
                let dy = -grump.y + target.y;
                let dx = -grump.x + target.x;
                let angle = Math.atan2(dy, dx);
                grump.dx = speed * 0.0003 * dt * Math.cos(angle);
                grump.dy = speed * 0.0003 * dt * Math.sin(angle);

                animationCounter -= dt;
                if (animationCounter < 0) animationCounter = 10000;
            };

            this.colliders = [grump, ...bricks];
            this.enemies = [grump];
            this.drawables = [grump, ...bricks];
            this.movers = [grump];

            eye.dying = () => {
                this.drawables.push(portal);
                this.colliders.push(portal);
                this.colliders = this.colliders.filter(c => c.y != -18 * sz);
                this.drawables = this.drawables.filter(d => d.y != -18 * sz);
                this.colliders.push(...otherBricks);
                this.drawables.push(...otherBricks);
            };

            grump.expiring = () => {
                eye.x = grump.x;
                eye.y = grump.y;
                this.colliders.push(eye);
                this.enemies.push(eye);
                this.drawables.push(eye);
                this.movers.push(eye);
            }
      
       }

        function LevelEnding() {
            Object.assign(this, initLevel());
            let selena = new Selena(0,-0.2,0,`Thanks my love for rescuing me, Pedro. I want some latynx babies with you.(THE END)`);
            let oldCollisionAction = selena.collisionAction.bind(selena);
            let p1 = {x:-0.5,y:-0.0};
            let p2 = {x:0.5,y:0.0};
            let p3 = {x:0,y:0.5};
            let p4 = {x:0,y:-0.5};
            let ps = [p1,p2,p3,p4];
            let randomP = () => {
                return ps[Math.floor(Math.random()*ps.length)];
            };
            let v = {x:0,y:0};
            selena.collisionAction = () => {
               oldCollisionAction();
               let classes = [Selena, Protagonist];
               let babyType = classes[Math.floor(Math.random()*2)];
               let rp = randomP();
               let newv = {x:(rp.x + v.x)/3,y:(rp.y + v.y)/3};
               let x = newv.x//(Math.random() - 0.5) * 2.5;
               let y = newv.y + selena.y//(Math.random() - 0.5) * 2.5;
               v = newv;
               let baby = new babyType(x,y,0);
               baby.x = x;
               baby.y = y;
               baby.halfWidth = sz/3;
               baby.vertices = getVertices(sz/3);
               this.drawables.push(baby);
            };
            this.drawables = [selena];
            this.colliders = [selena];
        }

        try {
            const canvas = document.getElementById('webglCanvas');
            gl = canvas.getContext('webgl');
            let width = window.innerWidth;
            let height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            if (!gl) {
                console.error("WebGL not supported");
                throw "No WebGL context";
            }

            const textureImages = [];
            let loadedTextures = 0;

            function loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = '*';
                    img.src = url;
                    img.onload = () => resolve(img);
                    img.onerror = (error) => reject(error);
                });
            }

            // Load all textures and store them in textureImages array in order
            const loadTextures = textureURLs.map((url, index) => {
                return loadImage(url).then((img) => {
                    textureImages[index] = img; // Ensure image is placed in the correct order
                    loadedTextures++;
                    if (loadedTextures === textureURLs.length) {
                        console.info('All images loaded successfully');
                        initWebGL(); // Proceed with WebGL initialization
                    }
                }).catch((error) => {
                    console.error('Failed to load image:', url, error);
                });
            });

            function initWebGL() {
                // Vertex shader program
                const vertexShaderSource = `
                attribute vec3 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform vec3 u_positionOffset;
                uniform vec2 u_textureOffset;
                uniform float u_aspectRatio;
                uniform float u_zoomFactor;

                const float far = 100.0; //farthest distance visible to camera
                const float near = 0.1; //closest distance visible to camera
                float fov = radians(25.0*u_zoomFactor); //vertical y axis field of view of the camera
                float f = 1.0 / tan(fov/2.0);                

                //projection and camera matrices
                mat4 projection = mat4(f/u_aspectRatio, 0.0, 0.0, 0.0, 
                                       0.0, f, 0.0, 0.0,
                                       0.0, 0.0, (near + far)/(near-far), 1.0,
                                       0.0, 0.0, (near * far * 2.0)/(near-far), 1.0);

                mat4 camera = mat4(1.0, 0.0, 0.0, 0.0, 
                                   0.0, 1.0, 0.0, 0.0,
                                   0.0, 0.0, 1.0, 0.0,
                                   0.0, 0.0, 1.0, 1.0);

                void main() {
                    gl_Position = projection * camera * vec4(
                            a_position.x + u_positionOffset.x,
                            a_position.y - u_positionOffset.y,
                            a_position.z + u_positionOffset.z, 1.0);
                    v_texCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y) - u_textureOffset;
                }
            `;

                // Fragment shader program
                const fragmentShaderSource = `
                precision mediump float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord) ;
                }
            `;

                // Shader compilation and linking utility functions
                function compileShader(source, type) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error("ERROR compiling shader: " + gl.getShaderInfoLog(shader));
                    }
                    return shader;
                }

                function createProgram(vertexShader, fragmentShader) {
                    const program = gl.createProgram();
                    gl.attachShader(program, vertexShader);
                    gl.attachShader(program, fragmentShader);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.error("ERROR linking program: " + gl.getProgramInfoLog(program));
                    }
                    return program;
                }

                // Create shaders and program
                const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
                program = createProgram(vertexShader, fragmentShader);

                // Get locations of the attributes and uniforms
                program.positionLocation = gl.getAttribLocation(program, "a_position");
                program.texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                program.textureOffsetLocation = gl.getUniformLocation(program, "u_textureOffset");
                program.positionOffsetLocation = gl.getUniformLocation(program, "u_positionOffset");
                program.textureLocation = gl.getUniformLocation(program, "u_texture");
                program.aspectRatioLocation = gl.getUniformLocation(program, "u_aspectRatio");
                program.zoomFactorLocation = gl.getUniformLocation(program, "u_zoomFactor");

                // Create buffer and load data
                program.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, program.positionBuffer);
                gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 5 * 4, 0);
                gl.enableVertexAttribArray(program.positionLocation);
                gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);
                gl.enableVertexAttribArray(program.texCoordLocation);

                // Create the textures
                textures = textureImages.map((img) => {
                    let texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    // Set texture wrapping and filtering
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    return texture;
                });

                // Event Handlers
                window.addEventListener('keyup', (event) => {
                    event.preventDefault();
                    keys[event.key] = false;
                });

                window.addEventListener('keydown', (event) => {
                    event.preventDefault();
                    keys[event.key] = true;
                });

                canvas.addEventListener('touchstart', (event) => { event.preventDefault(); document.querySelector("#buttons").style.visibility = "visible"; });
                document.querySelector("#left").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowLeft"] = true; });
                document.querySelector("#left").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowLeft"] = false; });
                document.querySelector("#right").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowRight"] = true; });
                document.querySelector("#right").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowRight"] = false; });
                document.querySelector("#up").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowUp"] = true; });
                document.querySelector("#up").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowUp"] = false; });
                document.querySelector("#down").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowDown"] = true; });
                document.querySelector("#down").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowDown"] = false; });
                document.querySelector("#attack").addEventListener("touchstart", (e) => { e.preventDefault(); keys[" "] = true; });
                document.querySelector("#attack").addEventListener("touchend", (e) => { e.preventDefault(); keys[" "] = false; });

                window.addEventListener('resize', (event) => {
                    event.preventDefault();
                    width = window.innerWidth;
                    height = window.innerHeight;
                    canvas.width = width;
                    canvas.height = height;
                });

                // WebGL Rendering Settings
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.SCISSOR_TEST);
                gl.depthFunc(gl.GEQUAL);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0.0, 0.0, 0.0, 1.0); // Set background color
                gl.clearDepth(0.0);



                level = new Level1();
               

                // TIME
                let previousTime = 0;

                // Render function to draw the map with texture
                function render(time) {
                    // Delta Time since last rendering
                    let dt = time - previousTime;
                    previousTime = time;

                    if(!dt || dt > 50 || protagonist.dead){
                        //requestAnimationFrame(render);
//                        return;
                    }
                    else{
                    // RESET SCREEN
                    // Set the aspect ratio uniform
                    gl.useProgram(program);
                    gl.uniform1f(program.aspectRatioLocation, canvas.width / canvas.height);
                    gl.uniform1f(program.zoomFactorLocation, zoomFactor);
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    if (level.transitionProgress < 1.0) level.transitionProgress += 0.01;
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.scissor((canvas.width * (1 - level.transitionProgress)) / 2, (canvas.height * (1 - level.transitionProgress)) / 2, canvas.width * level.transitionProgress, canvas.height * level.transitionProgress);

                    // BACKGROUND DRAW
                    background.textureOffset = [worldOffsetX / 3, worldOffsetY / 3];
                    background.draw(dt);

                    // PROTAGONIST DRAW
                    // Choosing the texture for the protagonist depending on action
                    let protagonistWalking = false;
                    if (keys["ArrowUp"] || keys["ArrowDown"] || keys["ArrowLeft"] || keys["ArrowRight"])
                        protagonistWalking = true;
                    if (protagonist.animation !== "blink") {
                        protagonist.animation = keys[" "] ? "attack" : protagonistWalking ? "walking" : "idle";
                    }
                    protagonist.draw(dt);

                    // TILES DRAW
                    level.drawables.forEach((d) => {
                        d.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                        d.draw(dt);
                    });

                    // DRAW PROTAGONIST BULLETS
                    bullets.forEach((b) => {
                        b.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                        b.draw(dt);
                        b.move(dt);
                    });

                    // CHECK COLLISION BETWEEN ENEMIES AND BULLETS
                    level.enemies.forEach((e) => {
                        if (e.dead) return;
                        bullets.forEach((b) => {
                            if (e.isColliding(b.x, b.y, sz)) {
                                if (e.dead) return;
                                let blood = new BloodParticle(e.x, e.y);
                                level.drawables.push(blood);
                                level.movers.push(blood);
                                b.damage(e);
                                if (e.dead) e.dying();
                            }
                        });
                    });

                    // MOVERS
                    level.movers.forEach(m => {
                        m.move(dt);
                        m.updateDxy(dt);
                    });

                    // DOOMERS LIFETIMES CLEANING
                    level.drawables.forEach(d => { if (d.lifetime !== undefined) d.expire(dt); });
                    bullets.forEach(b => { if (b.lifetime !== undefined) b.expire(dt); });
                    bullets = bullets.filter(b => { return b.lifetime === undefined || !(b.expired); });
                    level.movers = level.movers.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.drawables = level.drawables.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.colliders = level.colliders.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.enemies = level.enemies.filter(m => { return m.lifetime === undefined || !(m.expired); });

                    // CONTROLS
                    if (controlsEnabled) {
                        const d = 0.0003 * protagonist.speed * dt; //delta or offset change

                        const oldOffsetX = worldOffsetX;
                        const oldOffsetY = worldOffsetY;

                        if (keys["ArrowLeft"]) { worldOffsetX += d; }
                        if (keys["ArrowRight"]) { worldOffsetX -= d; }
                        if (keys["ArrowUp"]) { worldOffsetY += d; }
                        if (keys["ArrowDown"]) { worldOffsetY -= d; }

                        // SAVE THE DIRECTION THAT PROTAGONIST IS HEADING TO (FOR SPAWNING BULLET DIRECTION LATER)
                        if (protagonistWalking) {
                            protagonist.dx = -worldOffsetX + oldOffsetX;
                            protagonist.dy = -worldOffsetY + oldOffsetY;
                        }

                        // REVERSE PROTAGONIST MOVEMENTS IF HITS AN OBJECT
                        level.colliders.forEach((c) => {
                            if (c.isColliding(-worldOffsetX, -worldOffsetY, sz)) {
                                worldOffsetX = oldOffsetX;
                                worldOffsetY = oldOffsetY;
                                c.collisionAction();
                            }
                        });

                        // SPAWN PROTAGONIST BULLETS
                        if (keys[" "]) {
                            keys[" "] = false;
                            protagonist.attack(protagonist.dx, protagonist.dy);
                        }
                    }//end if control enabled
}
                    // LOOP
                    if (!protagonist.dead)
                        requestAnimationFrame(render);
                }

                // Start the rendering loop
                render(0);
            }
        } catch (e) {
            console.error("PROGRAM EXIT : ", e);
        }
    </script>
</body>

</html>

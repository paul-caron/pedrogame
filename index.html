<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pedro Escobar 2025</title>
    <style>
        body {
            user-select: none;
            margin: 0;
        }

        #dialogBox {
            width: 100%;
            text-align: center;
            text-shadow: -2px 2px 0px black, 2px 2px 0px black,
                -2px -2px 0px black, 2px -2px 0px black;
            color: #B77;
            font-weight: bolder;
            font-size: 3em;
            z-index: 2;
            position: fixed;
            left: 0px;
            top: 2em;
            white-space: pre-wrap;
        }

        #buttons {
            visibility: hidden;
        }

        button,
        #music,
        #zoomIn,
        #zoomOut {
            padding: 0px 0px 0px 0px;
            box-sizing: border-box;
            position: fixed;
            z-index: 10;
            font-size: 3em;
            height: 1em;
            line-height: 1em;
            text-align: center;
            width: 1em;
            font-style: new courier, monospace;
            border-radius: 50%;
            padding: 0px 0px 0px 0px;
            margin: 0px 0px 0px 0px;
            border: 2px solid brown;
        }

        #music {
            left: 0;
            top: 0;
        }

        #zoomIn {
            left: 0;
            top: 1em;
        }

        #zoomOut {
            left: 0em;
            top: 2em;
        }

        canvas {
            background-color: beige;
            top: 0px;
            left: 0px;
            display: block;
            border: 1px solid white;
        }

        audio {
            display: none;
        }
    </style>
</head>

<body>
    <pre id="dialogBox"></pre>
    <div id="buttons">
        <button id="left" style="left: 0em; bottom: 4em;">&nbsp;</button>
        <button id="up" style="left: 1em; bottom: 5em;">&nbsp;</button>
        <button id="right" style="left: 2em; bottom: 4em;">&nbsp;</button>
        <button id="down" style="left: 1em; bottom: 3em;">&nbsp;</button>
        <button id="attack" style="right: 1em; bottom: 4em;"></button>
    </div>
    <audio id="hardgroove" src="assets/pedrohard.mp3" type="audio/mp3" preload="auto" loop>
    </audio>
    <audio id="fmtechno" src="assets/fmtechno.mp3" type="audio/mp3" preload="auto" loop>
    </audio>
    <audio id="ether" src="assets/pedroEther.mp3" type="audio/mp3" preload="auto" loop>
    </audio>
    <audio id="dorienigm" src="assets/dorienigm.mp3" type="audio/mp3" preload="auto" loop>
    </audio>
    <audio id="mom" src="assets/mom.wav" type="audio/wav" preload="auto" loop>
    </audio>
    <button id="music" onClick="audio.paused?audio.play():audio.pause();">ðŸŽµ</button>
    <button id="zoomIn" onClick="if(zoomFactor>0)zoomFactor-=0.25;">&plus;</button>
    <button id="zoomOut" onClick="if(zoomFactor<2)zoomFactor+=0.25;">&minus;</button>
    <canvas id="webglCanvas"></canvas>
    <script src="src/classes.js"></script>
    <script src="src/levels.js"></script>
    <script>
        // Globals
        let level;
        let protagonist;
        let background;
        let foreground;
        let bullets;
        let audios = ["#fmtechno", "#hardgroove", "#dorienigm", "#mom"];
        let audioIndex = 2;
        let audio = document.querySelector(audios[audioIndex]);
        let gl;
        let program;
        let textures;
        let zoomFactor = 1.25;
        // Variables for world offset and control keys
        let worldOffsetX = 0;
        let worldOffsetY = 0;
        let keys = {};
        let controlsEnabled = true;
        let collectables = {
            //'item': number,
        };

        function dialog(text, callback = () => { }) {
            const dialogBox = document.getElementById('dialogBox');
            dialogBox.innerText = text;
            setTimeout(() => {
                dialogBox.innerText = "";
                callback();
            },
                3000);
        }

        function restart(){
            keys = {};
            level = new window[level.constructor.name]();
            let weapon = protagonist.weapon;
            let ammoType = protagonist.ammoType;
            let strength = protagonist.strength;
            let speed = protagonist.speed;
            protagonist = new Protagonist();
            protagonist.weapon = weapon;
            protagonist.ammoType = ammoType;
            protagonist.strength = strength;
            protagonist.speed = speed;
            audio.pause();
            audio = document.querySelector(audios[audioIndex]);
            audio.play();
        }

        function die() {
            protagonist.dead = true;
            audio.pause();
            audio = document.querySelector("#ether");
            audio.play();
            let answer = confirm('restart level?');
            if(answer) restart();
        }

        function initLevel() {
            controlsEnabled = true;
            bullets = [];
            worldOffsetX = 0;
            worldOffsetY = 0;
            return { colliders: [], enemies: [], drawables: [], movers: [], transitionProgress: 0.0 }
        }

        const assetsRoot = "assets/";

        const textureURLs = [
            assetsRoot + 'sierpinski.png',
            assetsRoot + 'pedro.png',
            assetsRoot + 'pedro2.png',
            assetsRoot + 'brick.png',
            assetsRoot + 'chest.png',
            assetsRoot + 'chest2.png',
            assetsRoot + 'chest3.png',
            assetsRoot + 'portal.png',
            assetsRoot + 'portal1.png',
            assetsRoot + 'portal2.png',
            assetsRoot + 'portal3.png',
            assetsRoot + 'portal4.png',
            assetsRoot + 'portal5.png',
            assetsRoot + 'syringe_up.png',
            assetsRoot + 'syringe_right.png',
            assetsRoot + 'syringe_down.png',
            assetsRoot + 'syringe_left.png',
            assetsRoot + 'chestopen.png',
            assetsRoot + 'dea.png',
            assetsRoot + 'dea2.png',
            assetsRoot + 'bloodparticle.png',
            assetsRoot + 'transparent.png',
            assetsRoot + 'npc.png',
            assetsRoot + 'npc2.png',
            assetsRoot + 'leaff.png',
            assetsRoot + 'ice.png',
            assetsRoot + 'ice2.png',
            assetsRoot + 'bubble.png',
            assetsRoot + 'doge.png',
            assetsRoot + 'doge2.png',
            assetsRoot + 'grump.png',
            assetsRoot + 'grump2.png',
            assetsRoot + 'selena.png',
            assetsRoot + 'selena2.png',
            assetsRoot + 'eye.png',
            assetsRoot + 'eye2.png',
            assetsRoot + 'eye3.png',
            assetsRoot + 'switch.png',
            assetsRoot + 'switch2.png',
            assetsRoot + 'switch3.png',
            assetsRoot + 'fogofwar.png',
            assetsRoot + 'credits.png',
        ];

        // vertices for the background x,y,z,u,v
        const backgroundVertices = new Float32Array([
            -1, 1, 0.0, 0.0, 1.0,
            -1, -1, 0.0, 0.0, 0.0,
            1, 1, 0.0, 1.0, 1.0,
            -1, -1, 0.0, 0.0, 0.0,
            1, 1, 0.0, 1.0, 1.0,
            1, -1, 0.0, 1.0, 0.0,
        ]);

        // tile vertices x,y,z,u,v
        const sz = 0.03125;
        const tileVertices = new Float32Array([
            -sz, sz, 0.0, 0.0, 1.0,
            -sz, -sz, 0.0, 0.0, 0.0,
            sz, sz, 0.0, 1.0, 1.0,
            -sz, -sz, 0.0, 0.0, 0.0,
            sz, sz, 0.0, 1.0, 1.0,
            sz, -sz, 0.0, 1.0, 0.0,
        ]);

        const getVertices = (size, offsetU = 0, offsetV = 0, div = 1) => {
        const vertices = new Float32Array([
            -size, size, 0.0, (0.0/div+offsetU), (1.0/div+offsetV),
            -size, -size, 0.0, (0.0/div+offsetU), (0.0/div+offsetV),
            size, size, 0.0, (1.0/div+offsetU), (1.0/div+offsetV),
            -size, -size, 0.0, (0.0/div+offsetU), (0.0/div+offsetV),
            size, size, 0.0, (1.0/div+offsetU), (1.0/div+offsetV),
            size, -size, 0.0, (1.0/div+offsetU), (0.0/div+offsetV),
        ]);
        return vertices;

        };

        // boss vertices x,y,z,u,v
        const boss_sz = sz * 4;
        const bossVertices = new Float32Array([
            -boss_sz, boss_sz, 0.0, 0.0, 1.0,
            -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
            boss_sz, boss_sz, 0.0, 1.0, 1.0,
            -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
            boss_sz, boss_sz, 0.0, 1.0, 1.0,
            boss_sz, -boss_sz, 0.0, 1.0, 0.0,
        ]);

        try {
            const canvas = document.getElementById('webglCanvas');
            gl = canvas.getContext('webgl');
            let width = window.innerWidth;
            let height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;

            if (!gl) {
                console.error("WebGL not supported");
                throw "No WebGL context";
            }

            const textureImages = [];
            let loadedTextures = 0;

            function loadImage(url) {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = '*';
                    img.src = url;
                    img.onload = () => resolve(img);
                    img.onerror = (error) => reject(error);
                });
            }

            // Load all textures and store them in textureImages array in order
            const loadTextures = textureURLs.map((url, index) => {
                return loadImage(url).then((img) => {
                    textureImages[index] = img; // Ensure image is placed in the correct order
                    loadedTextures++;
                    if (loadedTextures === textureURLs.length) {
                        console.info('All images loaded successfully');
                        initWebGL(); // Proceed with WebGL initialization
                    }
                }).catch((error) => {
                    console.error('Failed to load image:', url, error);
                });
            });

            function initWebGL() {
                // Vertex shader program
                const vertexShaderSource = `
                attribute vec3 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform vec3 u_positionOffset;
                uniform vec2 u_textureOffset;
                uniform float u_aspectRatio;
                uniform float u_zoomFactor;

                const float far = 100.0; //farthest distance visible to camera
                const float near = 0.1; //closest distance visible to camera
                float fov = radians(25.0*u_zoomFactor); //vertical y axis field of view of the camera
                float f = 1.0 / tan(fov/2.0);                

                //projection and camera matrices
                mat4 projection = mat4(f/u_aspectRatio, 0.0, 0.0, 0.0, 
                                       0.0, f, 0.0, 0.0,
                                       0.0, 0.0, (near + far)/(near-far), 1.0,
                                       0.0, 0.0, (near * far * 2.0)/(near-far), 1.0);

                mat4 camera = mat4(1.0, 0.0, 0.0, 0.0, 
                                   0.0, 1.0, 0.0, 0.0,
                                   0.0, 0.0, 1.0, 0.0,
                                   0.0, 0.0, 1.0, 1.0);

                void main() {
                    gl_Position = projection * camera * vec4(
                            a_position.x + u_positionOffset.x,
                            a_position.y - u_positionOffset.y,
                            a_position.z + u_positionOffset.z, 1.0);
                    v_texCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y) - u_textureOffset;
                }
            `;

                // Fragment shader program
                const fragmentShaderSource = `
                precision mediump float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord) ;
                }
            `;

                // Shader compilation and linking utility functions
                function compileShader(source, type) {
                    const shader = gl.createShader(type);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error("ERROR compiling shader: " + gl.getShaderInfoLog(shader));
                    }
                    return shader;
                }

                function createProgram(vertexShader, fragmentShader) {
                    const program = gl.createProgram();
                    gl.attachShader(program, vertexShader);
                    gl.attachShader(program, fragmentShader);
                    gl.linkProgram(program);
                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.error("ERROR linking program: " + gl.getProgramInfoLog(program));
                    }
                    return program;
                }

                // Create shaders and program
                const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
                program = createProgram(vertexShader, fragmentShader);

                // Get locations of the attributes and uniforms
                program.positionLocation = gl.getAttribLocation(program, "a_position");
                program.texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
                program.textureOffsetLocation = gl.getUniformLocation(program, "u_textureOffset");
                program.positionOffsetLocation = gl.getUniformLocation(program, "u_positionOffset");
                program.textureLocation = gl.getUniformLocation(program, "u_texture");
                program.aspectRatioLocation = gl.getUniformLocation(program, "u_aspectRatio");
                program.zoomFactorLocation = gl.getUniformLocation(program, "u_zoomFactor");

                // Create buffer and load data
                program.positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, program.positionBuffer);
                gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 5 * 4, 0);
                gl.enableVertexAttribArray(program.positionLocation);
                gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);
                gl.enableVertexAttribArray(program.texCoordLocation);

                // Create the textures
                textures = textureImages.map((img) => {
                    let texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                    gl.generateMipmap(gl.TEXTURE_2D);
                    // Set texture wrapping and filtering
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    return texture;
                });

                // Event Handlers
                window.addEventListener('keyup', (event) => {
                    event.preventDefault();
                    keys[event.key] = false;
                });

                window.addEventListener('keydown', (event) => {
                    event.preventDefault();
                    keys[event.key] = true;
                });

                canvas.addEventListener('touchstart', (event) => { event.preventDefault(); document.querySelector("#buttons").style.visibility = "visible"; });
                document.querySelector("#left").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowLeft"] = true; });
                document.querySelector("#left").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowLeft"] = false; });
                document.querySelector("#right").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowRight"] = true; });
                document.querySelector("#right").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowRight"] = false; });
                document.querySelector("#up").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowUp"] = true; });
                document.querySelector("#up").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowUp"] = false; });
                document.querySelector("#down").addEventListener("touchstart", (e) => { e.preventDefault(); keys["ArrowDown"] = true; });
                document.querySelector("#down").addEventListener("touchend", (e) => { e.preventDefault(); keys["ArrowDown"] = false; });
                document.querySelector("#attack").addEventListener("touchstart", (e) => { e.preventDefault(); keys[" "] = true; });
                document.querySelector("#attack").addEventListener("touchend", (e) => { e.preventDefault(); keys[" "] = false; });

                window.addEventListener('resize', (event) => {
                    event.preventDefault();
                    width = window.innerWidth;
                    height = window.innerHeight;
                    canvas.width = width;
                    canvas.height = height;
                });

                // WebGL Rendering Settings
                gl.enable(gl.DEPTH_TEST);
                gl.enable(gl.SCISSOR_TEST);
                gl.depthFunc(gl.GEQUAL);
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.clearColor(0.0, 0.0, 0.0, 1.0); // Set background color
                gl.clearDepth(0.0);



                level = new Level1();
               

                // TIME
                let previousTime = 0;

                // Render function to draw the map with texture
                function render(time) {
                    // Delta Time since last rendering
                    let dt = time - previousTime;
                    if (!(dt < 10))
                    previousTime = time;

                    if(!dt || dt > 32 || dt < 10 || protagonist.dead){
                        //requestAnimationFrame(render);
//                        return;
                    }
                    else{
                    // RESET SCREEN
                    // Set the aspect ratio uniform
                    gl.useProgram(program);
                    gl.uniform1f(program.aspectRatioLocation, canvas.width / canvas.height);
                    gl.uniform1f(program.zoomFactorLocation, zoomFactor);
                    gl.viewport(0, 0, canvas.width, canvas.height);
                    if (level.transitionProgress < 1.0) level.transitionProgress += 0.01;
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    gl.scissor((canvas.width * (1 - level.transitionProgress)) / 2, (canvas.height * (1 - level.transitionProgress)) / 2, canvas.width * level.transitionProgress, canvas.height * level.transitionProgress);

                    // BACKGROUND DRAW
                    background.textureOffset = [worldOffsetX / 3, worldOffsetY / 3];
                    background.draw(dt);

                    // PROTAGONIST DRAW
                    // Choosing the texture for the protagonist depending on action
                    let protagonistWalking = false;
                    if (keys["ArrowUp"] || keys["ArrowDown"] || keys["ArrowLeft"] || keys["ArrowRight"])
                        protagonistWalking = true;
                    if (protagonist.animation !== "blink") {
                        protagonist.animation = keys[" "] ? "attack" : protagonistWalking ? "walking" : "idle";
                    }
                    protagonist.draw(dt);

                    // TILES DRAW
                    level.drawables.forEach((d) => {
                        d.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                        d.draw(dt);
                    });

                    // DRAW PROTAGONIST BULLETS
                    bullets.forEach((b) => {
                        b.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                        b.draw(dt);
                        b.move(dt);
                    });

                    // CHECK COLLISION BETWEEN ENEMIES AND BULLETS
                    level.enemies.forEach((e) => {
                        if (e.dead) return;
                        bullets.forEach((b) => {
                            if (e.isColliding(b.x, b.y, sz)) {
                                if (e.dead) return;
                               // let blood = new BloodParticle((e.x+b.x)/2, (e.y+b.y)/2);
                                let x = (Math.max(e.x - e.halfWidth, b.x-b.halfWidth)+Math.min(e.x+e.halfWidth, b.x+b.halfWidth))/2;
                                let y = (Math.max(e.y - e.halfWidth, b.y-b.halfWidth)+Math.min(e.y+e.halfWidth, b.y+b.halfWidth))/2;
                                let blood = new BloodParticle(x, y);
                               // let blood = new BloodParticle((e.x*e.halfWidth+b.x*b.halfWidth)/(2*(e.halfWidth+b.halfWidth), (e.y*e.halfWidth+b.y*b.halfWidth)/(2*(e.halfWidth*b.halfWidth))));
                                level.drawables.push(blood);
                                level.movers.push(blood);
                                blood.updateDxy = (dt) => {
                                    let angle = Math.atan2(blood.dy, blood.dx);
                                    blood.dx = Math.cos(angle+Math.PI/90)/800 ;
                                    blood.dy = Math.sin(angle+Math.PI/90)/800 ;
                                };
                                b.damage(e);
                                if (e.dead) e.dying();
                            }
                        });
                    });

                    // MOVERS
                    level.movers.forEach(m => {
                        m.move(dt);
                        m.updateDxy(dt);
                    });

                    // DOOMERS LIFETIMES CLEANING
                    level.drawables.forEach(d => { if (d.lifetime !== undefined) d.expire(dt); });
                    bullets.forEach(b => { if (b.lifetime !== undefined) b.expire(dt); });
                    bullets = bullets.filter(b => { return b.lifetime === undefined || !(b.expired); });
                    level.movers = level.movers.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.drawables = level.drawables.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.colliders = level.colliders.filter(m => { return m.lifetime === undefined || !(m.expired); });
                    level.enemies = level.enemies.filter(m => { return m.lifetime === undefined || !(m.expired); });

                    // CONTROLS
                    if (controlsEnabled) {
                        const d = 0.0003 * protagonist.speed * dt; //delta or offset change

                        const oldOffsetX = worldOffsetX;
                        const oldOffsetY = worldOffsetY;

                        if (keys["ArrowLeft"]) { worldOffsetX += d; }
                        if (keys["ArrowRight"]) { worldOffsetX -= d; }
                        if (keys["ArrowUp"]) { worldOffsetY += d; }
                        if (keys["ArrowDown"]) { worldOffsetY -= d; }

                        // SAVE THE DIRECTION THAT PROTAGONIST IS HEADING TO (FOR SPAWNING BULLET DIRECTION LATER)
                        if (protagonistWalking) {
                            protagonist.dx = -worldOffsetX + oldOffsetX;
                            protagonist.dy = -worldOffsetY + oldOffsetY;
                        }

                        // REVERSE PROTAGONIST MOVEMENTS IF HITS AN OBJECT
                        level.colliders.forEach((c) => {
                            if (c.isColliding(-worldOffsetX, -worldOffsetY, sz)) {
                                worldOffsetX = oldOffsetX;
                                worldOffsetY = oldOffsetY;
                                c.collisionAction();
                            }
                        });

                        // SPAWN PROTAGONIST BULLETS
                        if (keys[" "]) {
                            keys[" "] = false;
                            protagonist.attack(protagonist.dx, protagonist.dy);
                        }
                    }//end if control enabled
                    
                    
                    
                    foreground.draw(dt);
}
                    // LOOP
                    if (!protagonist.dead)
                        requestAnimationFrame(render);
                }

                // Start the rendering loop
                render(0);
            }
        } catch (e) {
            console.error("PROGRAM EXIT : ", e);
        }
    </script>
</body>

</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pedro Escobar</title>
    <style>
        body { user-select: none; margin: 0;}
        #dialogBox {
            width: 100%;
            text-align: center;
            text-shadow: -2px 2px 0px black, 2px 2px 0px black,
                         -2px -2px 0px black, 2px -2px 0px black ;
            color: #B77;
            font-weight: bolder;
            font-size: 3em;
            z-index:2;
            position: fixed;
            left:0px;
            top:2em;
            white-space: pre-wrap; 
        }
        #buttons {
        	visibility: hidden;
        }
        button,#music, #zoomIn, #zoomOut {
            padding: 0px 0px 0px 0px;
            box-sizing:border-box;
            position: fixed;
            z-index:10;
            font-size: 3em;
            height: 1em;
            line-height: 1em;
            text-align: center;
            width: 1em;
            font-style: new courier, monospace;
            border-radius: 50%;
            padding: 0px 0px 0px 0px;
            margin: 0px 0px 0px 0px;
            border: 2px solid brown;
        }
        #music {left:0;top:0;}
        #zoomIn {left:0;top:1em;}
        #zoomOut {left:0em;top:2em;}
        canvas { background-color:beige;top:0px;left:0px;display: block; border: 1px solid white;}
        audio {display: none;}
    </style>
</head>
<body>
    <pre id="dialogBox"></pre>
    <div id="buttons">
    <button id="left" style="left: 0em; bottom: 4em;" >&nbsp;</button>
    <button id="up" style="left: 1em; bottom: 5em;">&nbsp;</button>
    <button id="right" style="left: 2em; bottom: 4em;">&nbsp;</button>
    <button id="down" style="left: 1em; bottom: 3em;">&nbsp;</button>
    <button id="attack" style="right: 1em; bottom: 4em;"></button>
    </div> 
    <audio id="hardgroove" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/pedrohard.mp3" type="audio/mp3" preload="auto" loop>
    </audio > 
    <audio id="fmtechno" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/fmtechno.mp3" type="audio/mp3" preload="auto" loop>
    </audio > 
    <audio id="ether" src="https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/pedroEther.mp3" type="audio/mp3" preload="auto" loop>
    </audio > 
    <button id="music" onClick="audio.paused?audio.play():audio.pause();">ðŸŽµ</button>
    <button id="zoomIn" onClick="zoomFactor-=0.25;">&plus;</button>
    <button id="zoomOut" onClick="zoomFactor+=0.25;">&minus;</button>
    <canvas id="webglCanvas"></canvas>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
<script>
    // Globals
    let level ;
    let protagonist ;
    let background;
    let bullets ;
    let audios = ["#fmtechno","#hardgroove"];
    let audioIndex = 0;
    let audio = document.querySelector(audios[audioIndex]);
    let gl ;
    let program ;
    let textures ;
    let zoomFactor = 1.0;
    // Variables for world offset and control keys
    let worldOffsetX = 0;
    let worldOffsetY = 0;
    let keys = {};
    let controlsEnabled = true;
    let collectables = {
    //'item': number,
    };

    function dialog(text, callback = ()=>{}){
        const dialogBox = document.getElementById('dialogBox');
        dialogBox.innerText = text;
        setTimeout(() => { 
            dialogBox.innerText=""; 
            callback();
            },
        3000);
    }

    function die() {
        protagonist.dead = true;
        audio.pause();
        audio = document.querySelector("#ether");
        audio.play();
    }

    function initLevel(){
        controlsEnabled = true;
        bullets = [];
        worldOffsetX = 0;
        worldOffsetY = 0;
        return {colliders : [], enemies : [], drawables : [], movers : [], transitionProgress: 0.0}
    }

    const assetsRoot = "https://cdn.jsdelivr.net/gh/paul-caron/webglstuff/assets/";

    const textureURLs = [
        assetsRoot+'sierpinski.png',
        assetsRoot+'pedro.png',
        assetsRoot+'pedro2.png',
        assetsRoot+'brick.png',
        assetsRoot+'chest.png',
        assetsRoot+'chest2.png',
        assetsRoot+'chest3.png',
        assetsRoot+'portal.png',
        assetsRoot+'portal1.png',
        assetsRoot+'portal2.png',
        assetsRoot+'portal3.png',
        assetsRoot+'portal4.png',
        assetsRoot+'portal5.png',
        assetsRoot+'syringe_up.png',
        assetsRoot+'syringe_right.png',
        assetsRoot+'syringe_down.png',
        assetsRoot+'syringe_left.png',
        assetsRoot+'chestopen.png',
        assetsRoot+'dea.png',
        assetsRoot+'dea2.png',
        assetsRoot+'bloodparticle.png',
        assetsRoot+'transparent.png',
        assetsRoot+'npc.png',
        assetsRoot+'npc2.png',
        assetsRoot+'leaff.png',
    ];

    // vertices for the background x,y,z,u,v
    const backgroundVertices = new Float32Array([
                -1,  1, 0.0, 0.0, 1.0,
                -1, -1, 0.0, 0.0, 0.0,
                 1,  1, 0.0, 1.0, 1.0,
                -1, -1, 0.0, 0.0, 0.0,
                 1,  1, 0.0, 1.0, 1.0,
                 1, -1, 0.0, 1.0, 0.0,
    ]);

    // tile vertices x,y,z,u,v
    const sz = 0.03125;
    const tileVertices = new Float32Array([
                -sz,  sz, 0.0, 0.0, 1.0,
                -sz, -sz, 0.0, 0.0, 0.0,
                 sz,  sz, 0.0, 1.0, 1.0,
                -sz, -sz, 0.0, 0.0, 0.0,
                 sz,  sz, 0.0, 1.0, 1.0,
                 sz, -sz, 0.0, 1.0, 0.0,
    ]);

    // boss vertices x,y,z,u,v
    const boss_sz = sz * 4;
    const bossVertices = new Float32Array([
        -boss_sz,  boss_sz, 0.0, 0.0, 1.0,
        -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
         boss_sz,  boss_sz, 0.0, 1.0, 1.0,
        -boss_sz, -boss_sz, 0.0, 0.0, 0.0,
         boss_sz,  boss_sz, 0.0, 1.0, 1.0,
         boss_sz, -boss_sz, 0.0, 1.0, 0.0,
    ]);

    // Drawable Tile Class
    class Drawable{
        constructor(_textures, vertices, x = 0, y = 0, z = 0){ //WebglTexturesIndices, VerticesArray (x,y,z,u,v), x, y, z)
            this.textures = _textures.map((i)=>textures[i]);
            this.textureIndex = 0; // index to active texture
            this.vertices = vertices;
            this.positionOffset = [0,0,0];
            this.textureOffset = [0,0];
            this.animations = {
                                  "idle":
                                  {
                                      "timePerFrame": 0, // time between animation frames
                                      "counter": 0,      // time counter for time left until next texture is displayed
                                      "textureIndices": [0], // texture indices in order of appearance in the animation
                                      "indexPointer": 0, // current index of textureIndices
                                  },
                              };
            this.animation = "idle"; //current animation name
            this.x = x;
            this.y = y;
            this.z = z;
            this.collisionAction = () => {};
        }
        draw(dt){ // delta time from previous render
            gl.useProgram(program);
            gl.uniform2f(program.textureOffsetLocation, ...this.textureOffset);
            gl.uniform3f(program.positionOffsetLocation, 
                         this.x+this.positionOffset[0],
                         this.y+this.positionOffset[1],
                         this.z+this.positionOffset[2]);
            let animation = this.animations[this.animation];
            this.textureIndex =  animation.textureIndices[animation.indexPointer];
            gl.bindTexture(gl.TEXTURE_2D, this.textures[this.textureIndex]);
            gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.STATIC_DRAW);
            gl.drawArrays(gl.TRIANGLES, 0, 6);
            animation.counter -= dt;
            if(animation.counter < 0){
                animation.counter = animation.timePerFrame;
                animation.indexPointer ++ ;
                animation.indexPointer %= animation.textureIndices.length;
            }
        }
    };
    
    // Mixin
    const Collider =  {
    	halfWidth : 0,
        x : 0,
        y : 0, 
        isColliding: function(x2, y2, halfWidth2){// other object's values
            let x1 = this.x;
            let y1 = this.y;
            let halfWidth1 = this.halfWidth;
            const horizontalOverlap = Math.abs(x1 - x2) < (halfWidth1 + halfWidth2);
            const verticalOverlap = Math.abs(y1 - y2) < (halfWidth1 + halfWidth2);
            return horizontalOverlap && verticalOverlap;
        },
        collisionAction : function(){} // to override;
    };
    
    // Mixin
    const Doomed = {
    	lifetime : 2000,
        expired : false,
        expire: function(dt) {
        	this.lifetime -= dt;
            if(this.lifetime < 0){
                this.expired = true;
            }
        }
    }
    
    // Mixin
    const Mover = {
    	x : 0,
        y : 0,
    	dx : 0,
        dy : 0,
        move : function(dt) {
            if(this.dead) return;
            this.x += this.dx;
            this.y += this.dy;
            this.updateDxy();
        },
        updateDxy : function(dt) { // to override
            //this.dx = ...;
            //this.dy = ...;
        },
    };
    
    class Bullet extends Drawable{
    	constructor(sz, textures, vertices, x = 0, y = 0, z = 0){
    	    super(textures, vertices, x,y,z);
             Object.assign(this, Mover);
             Object.assign(this, Doomed);
             Object.assign(this, Collider);
             this.halfWidth = sz;
             this.x = x;
             this.y = y;
             this.power = 1; //damage power
             this.animations.spin = {
                                      "timePerFrame": 100, // time between animation frames
                                      "counter": 0,      // time counter for time left until next texture is displayed
                                      "textureIndices": [0,1,2,3], // texture indices in order of appearance in the animation
                                      "indexPointer": 0, // current index of textureIndices
                              };
        }
        damage = function(enemy){
            enemy.life -= this.power;
            if(enemy.life<=0) enemy.dead = true;
            if(enemy.dead) enemy.lifetime = 2000; 
        }
    }

    class Fixture extends Drawable{
    	constructor(sz, textures, vertices, x = 0, y = 0, z = 0){
    	    super(textures, vertices, x,y,z);
            Object.assign(this, Collider);
            this.halfWidth = sz;
            this.x = x;
            this.y = y;
        }
    }

    class Enemy extends Drawable{
    	constructor(sz, textures, vertices, x = 0, y = 0, z = 0){
    	    super(textures, vertices, x,y,z);
            Object.assign(this, Mover);
            Object.assign(this, Collider);
            Object.assign(this, Doomed);
            this.halfWidth = sz;
            this.x = x;
            this.y = y;
            this.life = 10;
            this.lifetime = Infinity;
        }
        dying = function(){} // override
    }

    class Particle extends Drawable{
    	constructor(textures, x, y){
            const sz = 0.004;
            const vertices = new Float32Array([
                 -sz,sz, 0.0, 0.0, 1.0,
                 -sz, -sz, 0.0, 0.0, 0.0,
                 sz, sz, 0.0, 1.0, 1.0,
                -sz, -sz, 0.0, 0.0, 0.0,
                 sz,  sz, 0.0, 1.0, 1.0,
                 sz, -sz, 0.0, 1.0, 0.0,
            ]);
    	    super(textures, vertices, x, y);
            Object.assign(this, Mover);
            Object.assign(this, Doomed);
            this.x = x;
            this.y = y;
            this.dx = (Math.random()-0.5) / 400;
            this.dy = (Math.random()-0.5) / 400;
            this.lifetime = 1000;
        }
    }

    class BloodParticle extends Particle{
    	constructor(x, y){
    	    super([20, 21], x, y);
            this.animations.blink  = {
                 "timePerFrame": 40,
                 "counter": 0,
                 "textureIndices": [0,1],
                 "indexPointer": 0,
            };
            this.animation = 'blink';
        }
    }

    class Leaf extends Drawable{
        constructor(x, y){
    	    super([24], tileVertices, x, y);
            Object.assign(this, Collider);
            Object.assign(this, Doomed);
            this.halfWidth = sz;
            this.x = x;
            this.y = y;
            this.lifetime = Infinity;
            this.collisionAction = () => {
                if(!collectables['leaf']) collectables['leaf'] = 1;
                else collectables['leaf'] += 1;
                dialog(`YOU FOUND A LEAF [${collectables['leaf']}]`);
                this.lifetime = 0;
                this.collisionAction = ()=>{};
            };
        }
    };

    class Brick extends Fixture{
    	constructor(x, y, z){
    	    super(sz, [3], tileVertices, x, y, z);
        }
    }

    class Portal extends Fixture{
    	constructor(x, y, z){
    	    super(sz, [7,8,9,10,11,12], tileVertices, x, y, z);
            this.animations.idle = {
                "timePerFrame": 20,
                "counter": 0,
                "textureIndices": [0,1,2,3,4,5],
                "indexPointer": 0,
            };
        }
    }

    class Chest extends Fixture{
    	constructor(x, y, z){
    	    super(sz, [6, 17], tileVertices, x, y, z);
        }
        open(){
            this.animations.idle.textureIndices = [1];
            this.collisionAction = () => {};
        }
    }

    class DEA extends Enemy{
    	constructor(x, y, z){
    	    super(sz, [18,19], tileVertices, x, y, z);
            this.collisionAction = ()=>{
                die();
                dialog("YOU WERE CAUGHT BY THE D.E.A.");
            };
            this.animations.walking = {
                "timePerFrame": 200,
                "counter": 0,
                "textureIndices": [0,1],
                "indexPointer": 0,
            };
            this.animation = 'walking';
            this.life = 15;
        }
    }

    class DEA_Boss extends Enemy{
    	constructor(x, y, z){
    	    super(boss_sz, [18,19], bossVertices, x, y, z);
            this.collisionAction = ()=>{
                die();
                dialog("YOU WERE CAUGHT BY THE D.E.A.");
            };
            this.animations.walking = {
                "timePerFrame": 200,
                "counter": 0,
                "textureIndices": [0,1],
                "indexPointer": 0,
            };
            this.animation = 'walking';
            this.life = 3000;
        }
    }

    class Protagonist extends Drawable{
    	constructor(){
    	    super([1,2,21], tileVertices, 0,0,0);
            this.animations.walking = {
                "timePerFrame": 200,
                "counter": 0,
                "textureIndices": [0,1],
                "indexPointer": 0,
             };
             this.animations.attack  = {
                 "timePerFrame": 0,
                 "counter": 0,
                 "textureIndices": [0],
                 "indexPointer": 0,
             };
             this.animations.blink  = {
                 "timePerFrame": 20,
                 "counter": 0,
                 "textureIndices": [0,2],
                 "indexPointer": 0,
             };
             this.weapon = null;
             this.ammoType= null;
             this.speed = 1;
             this.strength = 1;
             this.dx = 0;
             this.dy = 0;
             let bullets = [] ;
        }
        attack(dx,dy){
             if(!this.weapon) return;
             if(!this.ammoType) return;
             let bullet = new Bullet(sz, [13,14,15,16], tileVertices, 0.0, 0.0, 0.0);
             bullet.dx = dx;
             bullet.dy = dy;
             bullet.x = -worldOffsetX;
             bullet.y = -worldOffsetY;
             bullet.lifetime = 2000;
             bullet.power = this.strength;
             bullet.collisionAction = ()=>{};
             bullet.animation = "spin";
             bullets.push(bullet);
        }
        getPosition(){
          return {x: -worldOffsetX, y: -worldOffsetY};
        }
    }
    
    class NPC extends Fixture{
    	constructor(x,y,z,text){
    	    super(sz,[22,23], tileVertices, x,y,z);
            this.text = text;
            this.collisionAction = function(){
            	dialog(this.text);
            }
        }
    };

    try{
        const canvas = document.getElementById('webglCanvas');
        gl = canvas.getContext('webgl');
        let width = window.innerWidth;
        let height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;

        if (!gl) {
            console.error("WebGL not supported");
            throw "No WebGL context";
        }

        const textureImages = [];
        let loadedTextures = 0;

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = '*';
                img.src = url;
                img.onload = () => resolve(img);
                img.onerror = (error) => reject(error);
            });
         }

        // Load all textures and store them in textureImages array in order
        const loadTextures = textureURLs.map((url, index) => {
            return loadImage(url).then((img) => {
                textureImages[index] = img; // Ensure image is placed in the correct order
                loadedTextures++;
                if (loadedTextures === textureURLs.length) {
                    console.info('All images loaded successfully');
                    initWebGL(); // Proceed with WebGL initialization
                }
            }).catch((error) => {
                console.error('Failed to load image:', url, error);
            });
        });
        

        function initWebGL() {
            // Vertex shader program
            const vertexShaderSource = `
                attribute vec3 a_position;
                attribute vec2 a_texCoord;
                varying vec2 v_texCoord;
                uniform vec3 u_positionOffset;
                uniform vec2 u_textureOffset;
                uniform float u_aspectRatio;
                uniform float u_zoomFactor;

                const float far = 100.0; //farthest distance visible to camera
                const float near = 0.1; //closest distance visible to camera
                float fov = radians(25.0*u_zoomFactor); //vertical y axis field of view of the camera
                float f = 1.0 / tan(fov/2.0);                

                //projection and camera matrices
                mat4 projection = mat4(f/u_aspectRatio, 0.0, 0.0, 0.0, 
                                       0.0, f, 0.0, 0.0,
                                       0.0, 0.0, (near + far)/(near-far), 1.0,
                                       0.0, 0.0, (near * far * 2.0)/(near-far), 1.0);

                mat4 camera = mat4(1.0, 0.0, 0.0, 0.0, 
                                   0.0, 1.0, 0.0, 0.0,
                                   0.0, 0.0, 1.0, 0.0,
                                   0.0, 0.0, 1.0, 1.0);

                void main() {
                    gl_Position = projection * camera * vec4(
                            a_position.x + u_positionOffset.x,
                            a_position.y - u_positionOffset.y,
                            a_position.z + u_positionOffset.z, 1.0);
                    v_texCoord = vec2(a_texCoord.x, 1.0 - a_texCoord.y) - u_textureOffset;
                }
            `;

            // Fragment shader program
            const fragmentShaderSource = `
                precision mediump float;
                varying vec2 v_texCoord;
                uniform sampler2D u_texture;
                void main() {
                    gl_FragColor = texture2D(u_texture, v_texCoord) ;
                }
            `;

            // Shader compilation and linking utility functions
            function compileShader(source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("ERROR compiling shader: " + gl.getShaderInfoLog(shader));
                }
                return shader;
            }

            function createProgram(vertexShader, fragmentShader) {
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error("ERROR linking program: " + gl.getProgramInfoLog(program));
                }
                return program;
            }

            // Create shaders and program
            const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);
            program = createProgram(vertexShader, fragmentShader);

            // Get locations of the attributes and uniforms
            program.positionLocation = gl.getAttribLocation(program, "a_position");
            program.texCoordLocation = gl.getAttribLocation(program, "a_texCoord");
            program.textureOffsetLocation = gl.getUniformLocation(program, "u_textureOffset");
            program.positionOffsetLocation = gl.getUniformLocation(program, "u_positionOffset");
            program.textureLocation = gl.getUniformLocation(program, "u_texture");
            program.aspectRatioLocation = gl.getUniformLocation(program, "u_aspectRatio");
            program.zoomFactorLocation = gl.getUniformLocation(program, "u_zoomFactor");

            // Create buffer and load data
            program.positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, program.positionBuffer);
            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 5 * 4, 0);
            gl.enableVertexAttribArray(program.positionLocation);
            gl.vertexAttribPointer(program.texCoordLocation, 2, gl.FLOAT, false, 5 * 4, 3 * 4);
            gl.enableVertexAttribArray(program.texCoordLocation);

            // Create the textures
            textures = textureImages.map((img) => {
                let texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
                gl.generateMipmap(gl.TEXTURE_2D);
                // Set texture wrapping and filtering
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                return texture;
            });

            // Event Handlers
            window.addEventListener('keyup', (event) => {
                event.preventDefault();
                keys[event.key] = false;
            });
             
            window.addEventListener('keydown', (event) => {
                event.preventDefault();
                keys[event.key] = true;
            });
            
            canvas.addEventListener('touchstart', (event) => { event.preventDefault(); document.querySelector("#buttons").style.visibility="visible";});            
            document.querySelector("#left").addEventListener("touchstart", (e)=>{e.preventDefault();keys["ArrowLeft"]=true;});
            document.querySelector("#left").addEventListener("touchend", (e)=>{e.preventDefault();keys["ArrowLeft"]=false;});
            document.querySelector("#right").addEventListener("touchstart", (e)=>{e.preventDefault();keys["ArrowRight"]=true;});
            document.querySelector("#right").addEventListener("touchend", (e)=>{e.preventDefault();keys["ArrowRight"]=false;});
            document.querySelector("#up").addEventListener("touchstart", (e)=>{e.preventDefault();keys["ArrowUp"]=true;});
            document.querySelector("#up").addEventListener("touchend", (e)=>{e.preventDefault();keys["ArrowUp"]=false;});
            document.querySelector("#down").addEventListener("touchstart", (e)=>{e.preventDefault();keys["ArrowDown"]=true;});
            document.querySelector("#down").addEventListener("touchend", (e)=>{e.preventDefault();keys["ArrowDown"]=false;});
            document.querySelector("#attack").addEventListener("touchstart", (e)=>{e.preventDefault();keys[" "]=true;});
            document.querySelector("#attack").addEventListener("touchend", (e)=>{e.preventDefault();keys[" "]=false;});

            window.addEventListener('resize', (event) => {
                event.preventDefault();
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width;
                canvas.height = height;
            });

            // WebGL Rendering Settings
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.SCISSOR_TEST);
            gl.depthFunc(gl.GEQUAL);           
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(0.0, 0.0, 0.0, 1.0); // Set background color
            gl.clearDepth(0.0);

            function Level1() {
                Object.assign(this, initLevel());
                protagonist = new Protagonist();
                background = new Drawable([0], backgroundVertices);

                dialog("USE ARROW KEYS TO MOVE AROUND",
                       ()=>{dialog("SPACE BAR FOR ATTACK")});

                let brick = new Brick(0.0, 0.2, 0.0);
                let chest = new Chest(-0.2, -0.0, 0.0);
                chest.collisionAction = () => {
                    protagonist.weapon="gun";
                    dialog("YOU FOUND A TRANQUILIZER GUN");
                    chest.open();
                };
                let chest2 = new Chest(0.0, -0.2, 0.0);
                chest2.collisionAction = () => {
                    protagonist.ammoType="fentanyl";
                    dialog("YOU FOUND FENTANYL TRANQUILIZER SHOTS");
                    chest2.open();
                };
                let chest3 = new Chest(0.2, -0.0, 0.0);
                chest3.collisionAction = () => {
                    dialog("YOU FOUND A LETTER FROM CHICKA MI AMOR:", () => {dialog('"HELP ME PEDRO!"<Selena Gomez>');});
                    chest3.open();
                };
                let portal = new Portal(0.0, 0.2+sz*2, 0.0);
                portal.collisionAction = () => {
                    protagonist.animation = "blink";
                    controlsEnabled = false;
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level2();
                           });
                    portal.collisionAction = () => {};
                };
                
                let npc= new NPC(0,-0.35,0,`"I think Grump took her to prison. Be careful of your enemies and of the booby traps."`);
                
                this.drawables = [chest, chest2, chest3, brick, portal, npc];
                this.colliders = [chest, chest2, chest3, brick, portal, npc];
                this.movers = [];
                this.enemies = [];
            };
            
            function Level2(){
                Object.assign(this, initLevel());

                let bricks = (()=>{
                    let result = [];
                    for(let x = -15, y=2; x < -8; x+=2, y+=2){
                        result.push(new Brick(x*sz, -0.2-sz*y, 0.0));
                        result.push(new Brick(x*sz, -0.2+sz*y, 0.0));
                    }
                    for(let x = -sz * 16; x < sz * 16; x+=sz*2)
                        result.push(new Brick(x, -0.2, 0.0));
                    return result;
                })();

                let bullet = new Bullet(sz,[13,14,15,16], tileVertices, 0.0, 0.4, 0.0);
                bullet.dx = 0;
                bullet.dy = -0.003;
                bullet.lifetime = 2000;
                bullet.collisionAction = ()=>{
                        die();
                	dialog("YOU STEPPED ON DIRTY NEEDLE", ()=>{
                	    dialog("NOW YOU ARE HIV POSITIVE AND GAY!");
                    });
                    bullet.dy = 0;
                    bullet.dx = 0;
                }

                let chest = new Chest(2.0, -0.2, 0.0);
                chest.collisionAction = () => {
                    dialog("YOU FOUND THE COCAINA (SPEED BUFF)");
                    protagonist.speed = 2.0;
                    chest.open();
                };

                let portal = new Portal(-2.0, -0.2, 0.0);
                portal.collisionAction = () => {
                    protagonist.animation = "blink";
                    controlsEnabled = false;
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level3();
                           });
                    portal.collisionAction = () => {};
                };
                
                let npc= new NPC(0,-0.35,0,`"It is a very big world we live in. Don't get lost."`);
            	this.colliders = [...bricks, bullet, chest, portal, npc];
                this.drawables = [bullet, ...bricks, chest, portal, npc];
                this.movers = [bullet];
                this.enemies = [];
            }
            
            function Level3(){
                Object.assign(this, initLevel());

                let bricks = (()=>{
                    let result = [];
                    for(let y = -0.4; y <= 0.4; y += sz*2)
                        result.push(new Brick(-sz*16, y, 0.0));
                    for(let y = -0.4; y <= 0.4; y += sz*2)
                        result.push(new Brick(sz*16, y, 0.0));
                    for(let x = -sz * 16; x < sz * 16; x+=sz*2)
                        result.push(new Brick(x, -0.4, 0.0));
                    for(let x = -sz * 16; x <= sz * 16; x+=sz*2)
                        result.push(new Brick(x, 0.4, 0.0));
                    return result;
                })();

                let dea = new DEA(0.2, -0.2, 0.0);
                dea.updateDxy = (dt) => {
                    dea.dy = 0;
                    if(dea.x >= 0.2) dea.dx = -0.0003*dt;
                    if(dea.x <= -0.2) dea.dx = 0.0003*dt;
                };

                let portal = new Portal(0.0, 0.2, 0.0);
                portal.collisionAction = () => {
                    protagonist.animation = "blink";
                    controlsEnabled = false;
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level4();
                           });
                    portal.collisionAction = () => {};
                };

            	this.colliders = [...bricks, dea];
                this.enemies = [dea];
                this.drawables = [...bricks, dea];
                this.movers = [dea];
                dea.dying = () => {
                    dialog("CONGRATS. YOUR FIRST KILL! CARTEL PRESTIGE GOES UP");
                    this.colliders.push(portal);
                    this.drawables.push(portal);
                };
            }

            function Level4(){
                Object.assign(this, initLevel());

                let portal = new Portal(0.0, 0.2, 0.0);
                portal.collisionAction = () => {
                    protagonist.animation = "blink";
                    controlsEnabled = false;
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level5();
                           });
                    portal.collisionAction = () => {};
                };

                let enemies = [];
                let enemyCount = 10;
                for(let i = 1; i<=enemyCount; i++){
                  let radius = 0.2 * i + 0.5;
                  let angle = Math.PI / 3 * i;
                  let x = Math.cos(angle) * radius;
                  let y = Math.sin(angle) * radius;
                  let dea = new DEA(x, y, 0.0);
                  dea.dx = 0;
                  dea.dy = 0;
                  dea.updateDxy = function(dt) {
                      if(!dt) return;
                      let homingTarget = protagonist.getPosition();
                      let dy = -dea.y + homingTarget.y;
                      let dx = -dea.x + homingTarget.x;
                      let angle = Math.atan2(dy,dx);
                      dea.dx = 0.0001 * dt * Math.cos(angle);
                      dea.dy = 0.0001 * dt * Math.sin(angle);
                  };
                  dea.dying = () => {
                      dialog(`${--enemyCount} enemies left`);
                      if(enemyCount === 0) {
                          this.drawables.push(portal); 
                          this.colliders.push(portal);
                      }
                  };
                  enemies.push(dea);
                }

            	this.colliders = [...enemies];
                this.enemies = [...enemies];
                this.drawables = [...enemies];
                this.movers = [...enemies];
            }

            function Level5(){
                Object.assign(this, initLevel());

                let bricks = (()=>{
                    let result = [];
                    for(let y = -18; y <= 18; y += 12)
                    for(let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz*x, sz*y, 0.0));
                    for(let y = -18; y <= 18; y += 2)
                    for(let x = -18; x <= 18; x += 12)
                        result.push(new Brick(sz*x, sz*y, 0.0));
                    return result;
                })();

                let portals = (()=>{
                    let results = [];
                    for(let y = -18; y < 18; y += 12)
                    for(let x = -18; x < 18; x += 12)
                    {
                        let portal = new Portal((x+2)*sz, (y+2)*sz, 0.0);
                        results.push(portal);
                    }
                    for(let y = -18; y < 18; y += 12)
                    for(let x = -18; x < 18; x += 12)
                    {
                        let portal = new Portal((x+10)*sz, (y+10)*sz, 0.0);
                        results.push(portal);
                    }
                    return results;
                })();

                for(let i=0;i<9;i++)
                    portals[i].collisionAction = ()=>{worldOffsetX=-(portals[i+1].x+sz*4);worldOffsetY=-(portals[i+1]).y-sz*4;};
                for(let i=9;i<18;i++)
                    portals[i].collisionAction = ()=>{worldOffsetX=-(portals[i-1].x-sz*4);worldOffsetY=-(portals[i-1]).y+sz*4;};

                let ports = portals.toSpliced(9, 1);
                ports[8].collisionAction = () => {worldOffsetX=-0;worldOffsetY=0;};
                ports[ports.length-1].collisionAction = () => {
                    controlsEnabled = false;
                    protagonist.animation="blink";
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation="idle";
                               level = new Level6();
                    });
                    ports[ports.length-1].collisionAction = () => {};
                };

                let chest = new Chest(-sz*8, -sz*8, 0.0);
                chest.collisionAction = () => {
                    dialog("YOU FOUND THE SHROOMS (STRENGTH BUFF)");
                    protagonist.strength += 1;
                    chest.open();
                };

            	this.colliders = [...bricks, ...ports, chest];
                this.enemies = [];
                this.drawables = [...bricks, ...ports, chest];
                this.movers = [];
            }

            function Level6(){
                Object.assign(this, initLevel());

                dialog(`"It is here that you die"`, () => {
                    dialog(`"Selena Gomez is ours. Mouhahaha!"`);
                });

                let portal = new Portal(0.0, -32*sz, 0.0);
                portal.collisionAction = () => {
                    controlsEnabled = false;
                    protagonist.animation = "blink";
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level7();
                           });
                    portal.collisionAction = () => {};
                };

                let bricks = (()=>{
                    let result = [];
                    for(let y = -18; y <= 18; y += 36)
                    for(let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz*x, sz*y, 0.0));
                    for(let y = -18; y <= 18; y += 2)
                    for(let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz*x, sz*y, 0.0));
                    return result;
                })();

                let otherBricks = (()=>{
                    let result = [];
                    for(let y = -36; y <= -18; y += 2)
                    for(let x = -18; x <= 18; x += 36)
                        result.push(new Brick(sz*x, sz*y, 0.0));
                    for(let x = -18; x <= 18; x += 2)
                        result.push(new Brick(sz*x, sz*-36, 0.0));
                    return result;
                })();

                let dea = new DEA_Boss(0, -0.4, 0.0);
                let animationCounter = 10000;
                dea.updateDxy = function(dt){//dt, {x:,y:}
                    let target = {x:0,y:-0.4};
                    let speed = 0.5;
                    if(animationCounter<2000){
                      target = protagonist.getPosition();
                      speed = 1.2;
                    }
                    if(!dt) return;
                    let dy = -dea.y + target.y;
                    let dx = -dea.x + target.x;
                    let angle = Math.atan2(dy,dx);
                    dea.dx = speed * 0.0003 * dt * Math.cos(angle);
                    dea.dy = speed * 0.0003 * dt * Math.sin(angle);

                    animationCounter -= dt;
                    if(animationCounter<0) animationCounter=10000;
                };

            	this.colliders = [dea, ...bricks];
                this.enemies = [dea];
                this.drawables = [dea, ...bricks];
                this.movers = [dea];
                dea.dying = () => {
                    this.drawables.push(portal);
                    this.colliders.push(portal);
                    this.colliders = this.colliders.filter(c=>c.y!=-18*sz);
                    this.drawables = this.drawables.filter(d=>d.y!=-18*sz);
                    this.colliders.push(...otherBricks);
                    this.drawables.push(...otherBricks);
                };
            }

            function Level7(){
                Object.assign(this, initLevel());

                let portal = new Portal(0.0, sz*5, 0.0);
                portal.collisionAction = () => {
                    controlsEnabled = false;
                    protagonist.animation = "blink";
                    dialog("YOU FOUND THE EXIT",
                           ()=>{
                               protagonist.animation = "idle";
                               level = new Level8();
                           });
                    portal.collisionAction = () => {};
                };

                let npc = new NPC(0, -sz*6, 0, `"Help me find 100 plants. There is some field straight up north"`);
                let oldCollisionAction = npc.collisionAction.bind(npc);
                npc.collisionAction = () => {
                    if(collectables['leaf']&&collectables['leaf']>100){
                        dialog(`"Thank you very much. Here is the exit"`);
                        this.colliders.push(portal);
                        this.drawables.push(portal);
                    }else{
                        oldCollisionAction();
                    }
                }
                let leaf = new Leaf(-sz*2, -sz*6);
                let leaves = (()=>{
                    let results = [];
                    for(let i=0;i<150;i++){
                        let x = (i-75)*sz*4;
                        let y = Math.sin(x) - sz*250;
                        results.push(new Leaf(x,y));
                    }
                    return results;
                })();
                this.drawables = [npc,leaf,...leaves];
                this.colliders = [npc,leaf,...leaves];
            }

            function Level8(){
                Object.assign(this, initLevel());

            }

            level = new Level1();
//            protagonist.weapon = "jfkdlsjf"; //remove when not debug
//            protagonist.ammoType = "djfkslfjkdsl"; //remove
//            level = new Level7();//remove
            
            // TIME
            let previousTime = 0;

            // Render function to draw the map with texture
            function render(time) {
                // Delta Time since last rendering
                let dt = time - previousTime;
                previousTime = time;

                // RESET SCREEN
                // Set the aspect ratio uniform
                gl.useProgram(program);
                gl.uniform1f(program.aspectRatioLocation, canvas.width/canvas.height);
                gl.uniform1f(program.zoomFactorLocation, zoomFactor);
                gl.viewport(0, 0, canvas.width, canvas.height);
                if(level.transitionProgress<1.0) level.transitionProgress += 0.01;
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                gl.scissor((canvas.width*(1-level.transitionProgress))/2,(canvas.height*(1-level.transitionProgress))/2,canvas.width*level.transitionProgress, canvas.height*level.transitionProgress);

                // BACKGROUND DRAW
                background.textureOffset = [worldOffsetX/3, worldOffsetY/3];
                background.draw(dt);

                // PROTAGONIST DRAW
                // Choosing the texture for the protagonist depending on action
                let protagonistWalking = false;
                if(keys["ArrowUp"] || keys["ArrowDown"] || keys["ArrowLeft"] || keys["ArrowRight"])
                  protagonistWalking = true;
                if(protagonist.animation!=="blink"){
                protagonist.animation = keys[" "]? "attack" : protagonistWalking? "walking" : "idle";
                }
                protagonist.draw(dt);

                // TILES DRAW
                level.drawables.forEach((d) => {
                	d.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                    d.draw(dt);
                });

                // DRAW PROTAGONIST BULLETS
                bullets.forEach((b) => {
                    b.positionOffset = [worldOffsetX, worldOffsetY, 0.0];
                    b.draw(dt);
                    b.move(dt);
                });                

                // CHECK COLLISION BETWEEN ENEMIES AND BULLETS
                level.enemies.forEach((e) => {
                    if(e.dead) return;
                    bullets.forEach((b) => {
                      if(e.isColliding(b.x,b.y,sz)){
                        let blood = new BloodParticle(e.x, e.y);
                        level.drawables.push(blood);
                        level.movers.push(blood);
                        b.damage(e);
                        if(e.dead) e.dying();
                      }
                    });
                });

                // MOVERS
                level.movers.forEach(m=>{
                    m.move(dt);
                    m.updateDxy(dt);
                });

                // DOOMERS LIFETIMES CLEANING
                level.drawables.forEach(d=>{if(d.lifetime !== undefined ) d.expire(dt);});
                bullets.forEach(b=>{if(b.lifetime !== undefined) b.expire(dt);});
                bullets = bullets.filter(b=>{return b.lifetime === undefined || !(b.expired);});
                level.movers = level.movers.filter(m => {return m.lifetime === undefined || !(m.expired);});
                level.drawables = level.drawables.filter(m => {return m.lifetime === undefined || !(m.expired);});
                level.colliders = level.colliders.filter(m => {return m.lifetime === undefined || !(m.expired);});
                level.enemies = level.enemies.filter(m => {return m.lifetime === undefined || !(m.expired);});

                // CONTROLS
                if(controlsEnabled){
                const d = 0.0003 * protagonist.speed * dt; //delta or offset change

                const oldOffsetX = worldOffsetX;
                const oldOffsetY = worldOffsetY;

                if(keys["ArrowLeft"]){ worldOffsetX += d; }
                if(keys["ArrowRight"]){ worldOffsetX -= d; }
                if(keys["ArrowUp"]){ worldOffsetY += d; }
                if(keys["ArrowDown"]){ worldOffsetY -= d; }
                
                // SAVE THE DIRECTION THAT PROTAGONIST IS HEADING TO (FOR SPAWNING BULLET DIRECTION LATER)
                if(protagonistWalking){
	            protagonist.dx = -worldOffsetX + oldOffsetX; 
	            protagonist.dy = -worldOffsetY + oldOffsetY;
                }
     
                // REVERSE PROTAGONIST MOVEMENTS IF HITS AN OBJECT
                level.colliders.forEach((c) => {
                    if(c.isColliding(-worldOffsetX, -worldOffsetY, sz)){
                        worldOffsetX = oldOffsetX;
                        worldOffsetY = oldOffsetY;
                        c.collisionAction();
                    }
                });

                // SPAWN PROTAGONIST BULLETS
                if(keys[" "]){
                    keys[" "]=false;
                    protagonist.attack(protagonist.dx, protagonist.dy);
                }
                }//end if control enabled

                // LOOP
                if(!protagonist.dead)
                requestAnimationFrame(render);
            }

            // Start the rendering loop
            render(0);
        }
    }catch(e){
        console.error("PROGRAM EXIT : ", e);
    }
</script>
</body>
</html>
